<script>
const QuizPlayer = (() => {
    let currentQuiz = null;
    let completionCallback = null;
    let sortableInstances = new Map();

    function init() {
        // Listen for modal close events to ensure cleanup
        Utils.listen('#quiz-modal-close', 'click', closeQuiz);
        window.addEventListener('beforeunload', cleanup);
    }

    function cleanup() {
        clearSortableInstances();
        currentQuiz = null;
        completionCallback = null;
    }

    function clearSortableInstances() {
        // Properly destroy all Sortable instances
        sortableInstances.forEach((instance, containerId) => {
            try {
                instance.destroy();
            } catch (error) {
                console.error(`Error destroying Sortable instance for ${containerId}:`, error);
            }
        });
        sortableInstances.clear();
    }

    function openQuiz(fabricObject, onComplete) {
        if (!fabricObject?.appData?.interactions?.features?.quiz) {
            console.error('No quiz data found for object');
            return;
        }

        cleanup(); // Ensure clean state before opening
        currentQuiz = fabricObject.appData.interactions.features.quiz;
        completionCallback = onComplete;

        renderQuiz();
        document.getElementById('quiz-modal').classList.add('active');
    }

    function closeQuiz() {
        document.getElementById('quiz-modal').classList.remove('active');
        cleanup();
    }

    function renderQuiz() {
        const container = document.getElementById('quiz-content');
        if (!container || !currentQuiz) return;

        container.innerHTML = '';
        currentQuiz.questions.forEach((question, index) => {
            const questionEl = document.createElement('div');
            questionEl.className = 'quiz-question';
            
            switch (question.type) {
                case 'matching':
                    renderMatching(questionEl, question, index);
                    break;
                case 'ordering':
                    renderOrdering(questionEl, question, index);
                    break;
                // Add other question types here
            }
            
            container.appendChild(questionEl);
        });
    }

    function renderMatching(container, question, index) {
        // Create matching container with two columns
        const matchingContainer = document.createElement('div');
        matchingContainer.className = 'matching-container';
        matchingContainer.id = `matching-${index}`;

        // Left column (fixed)
        const leftCol = document.createElement('div');
        leftCol.className = 'matching-left';
        question.pairs.forEach((pair, pairIndex) => {
            const item = document.createElement('div');
            item.className = 'matching-item fixed';
            item.textContent = pair.left;
            leftCol.appendChild(item);
        });

        // Right column (sortable)
        const rightCol = document.createElement('div');
        rightCol.className = 'matching-right';
        rightCol.id = `matching-right-${index}`;
        
        // Shuffle right-side items
        const shuffledRight = [...question.pairs]
            .sort(() => Math.random() - 0.5)
            .map(pair => pair.right);
        
        shuffledRight.forEach(text => {
            const item = document.createElement('div');
            item.className = 'matching-item draggable';
            item.textContent = text;
            rightCol.appendChild(item);
        });

        matchingContainer.appendChild(leftCol);
        matchingContainer.appendChild(rightCol);
        container.appendChild(matchingContainer);

        // Initialize Sortable
        const sortable = new Sortable(rightCol, {
            group: `matching-${index}`,
            animation: 150,
            ghostClass: 'sortable-ghost'
        });
        
        // Store instance for cleanup
        sortableInstances.set(rightCol.id, sortable);
    }

    function renderOrdering(container, question, index) {
        const orderingContainer = document.createElement('div');
        orderingContainer.className = 'ordering-container';
        orderingContainer.id = `ordering-${index}`;

        // Create and shuffle items
        const shuffledItems = [...question.items]
            .sort(() => Math.random() - 0.5);
        
        shuffledItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = 'ordering-item';
            itemEl.textContent = item;
            orderingContainer.appendChild(itemEl);
        });

        container.appendChild(orderingContainer);

        // Initialize Sortable
        const sortable = new Sortable(orderingContainer, {
            animation: 150,
            ghostClass: 'sortable-ghost'
        });
        
        // Store instance for cleanup
        sortableInstances.set(orderingContainer.id, sortable);
    }

    function checkAnswers() {
        if (!currentQuiz) return;

        const results = currentQuiz.questions.map((question, index) => {
            switch (question.type) {
                case 'matching':
                    return checkMatchingAnswer(question, index);
                case 'ordering':
                    return checkOrderingAnswer(question, index);
                default:
                    return { correct: false, message: 'Unsupported question type' };
            }
        });

        showResults(results);
        
        // If all questions are answered correctly
        if (results.every(r => r.correct)) {
            setTimeout(() => {
                closeQuiz();
                if (completionCallback) completionCallback();
            }, 2000);
        }
    }

    function checkMatchingAnswer(question, index) {
        const rightCol = document.getElementById(`matching-right-${index}`);
        if (!rightCol) return { correct: false, message: 'Question not found' };

        const currentOrder = Array.from(rightCol.children).map(el => el.textContent);
        const correctOrder = question.pairs.map(pair => pair.right);

        const isCorrect = currentOrder.every((item, i) => item === correctOrder[i]);
        return {
            correct: isCorrect,
            message: isCorrect ? 'Correct!' : 'Try again'
        };
    }

    function checkOrderingAnswer(question, index) {
        const container = document.getElementById(`ordering-${index}`);
        if (!container) return { correct: false, message: 'Question not found' };

        const currentOrder = Array.from(container.children).map(el => el.textContent);
        const correctOrder = question.items;

        const isCorrect = currentOrder.every((item, i) => item === correctOrder[i]);
        return {
            correct: isCorrect,
            message: isCorrect ? 'Correct!' : 'Try again'
        };
    }

    function showResults(results) {
        results.forEach((result, index) => {
            const questionEl = document.querySelector(`.quiz-question:nth-child(${index + 1})`);
            if (questionEl) {
                questionEl.classList.remove('correct', 'incorrect');
                questionEl.classList.add(result.correct ? 'correct' : 'incorrect');
                
                // Show feedback message
                let feedback = questionEl.querySelector('.feedback');
                if (!feedback) {
                    feedback = document.createElement('div');
                    feedback.className = 'feedback';
                    questionEl.appendChild(feedback);
                }
                feedback.textContent = result.message;
            }
        });
    }

    return {
        init,
        openQuiz,
        closeQuiz,
        checkAnswers,
        cleanup
    };
})();
</script>