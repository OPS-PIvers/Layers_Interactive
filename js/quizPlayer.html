const QuizPlayer = (() => {
    const playerModal = document.getElementById('quiz-player-modal');
    const playerTitle = document.getElementById('quiz-player-title');
    const playerBody = document.getElementById('quiz-player-body');
    const promptElement = document.getElementById('quiz-question-prompt');
    const answerArea = document.getElementById('quiz-question-answer-area');
    const feedbackArea = document.getElementById('quiz-question-feedback-area');
    const nextButton = document.getElementById('quiz-player-next-button');

    const resultsModal = document.getElementById('quiz-results-modal');
    const resultsTitle = document.getElementById('quiz-results-title');
    const resultsBody = document.getElementById('quiz-results-body');
    const resultsScore = document.getElementById('quiz-results-score');
    const resultsEmailSection = document.getElementById('quiz-results-email-section');
    const resultsEmailInput = document.getElementById('quiz-results-email-input');
    const resultsSendButton = document.getElementById('quiz-results-send-button');
     const resultsEmailStatus = document.getElementById('quiz-results-email-status');
     const resultsCreatorMessage = document.getElementById('quiz-results-creator-message');
     const resultsEmailStatusCreator = document.getElementById('quiz-results-email-status-creator');
    const resultsCloseButton = document.getElementById('quiz-results-close-button');


    let currentQuiz = null; // Full quiz data { enabled, questions, feedbackTiming, ... }
    let currentElementData = null; // Data of the element that triggered the quiz
    let currentQuestionIndex = 0;
    let userAnswers = {}; // Store answers keyed by questionId: { questionId: { answer: ..., isCorrect: bool, ... }, ...}
    let quizStartTime = null;
    let onQuizCompleteCallback = null; // Callback from InteractionHandler

    // Store SortableJS instances to destroy them later
    let sortableInstances = [];

    function _init() {
        Utils.listen(nextButton, 'click', handleNextButtonClick);
        Utils.listen(resultsSendButton, 'click', handleSendEmailToUser);
        Utils.listen(resultsCloseButton, 'click', closeResultsModal);
        // Close results modal also attached inline
    }

    // fabricObject is the element that triggered the quiz
    // onComplete is called when the quiz flow (including results modal) is finished
    function openQuiz(fabricObject, onComplete) {
        if (!playerModal || !fabricObject || !fabricObject.appData) {
            console.error("Quiz Player cannot open: Missing modal or element data.");
            return;
        }
        currentElementData = fabricObject.appData;
        currentQuiz = currentElementData.interactions?.features?.quiz;

        if (!currentQuiz || !currentQuiz.enabled || !currentQuiz.questions || currentQuiz.questions.length === 0) {
            console.warn("Attempted to open quiz, but it's disabled or has no questions.", currentElementData.id);
             // Optionally show a message? Or just do nothing.
             // If called within sequence, need to ensure sequence advances even if quiz doesn't show.
             if (onComplete) onComplete(); // Immediately call completion callback if no quiz shown
            return;
        }

        console.log("Opening Quiz Player for:", currentElementData.nickname || currentElementData.id);

        // Reset state
        currentQuestionIndex = 0;
        userAnswers = {};
        quizStartTime = Date.now();
        onQuizCompleteCallback = onComplete;
        clearSortableInstances(); // Clear any old sortable instances

        playerTitle.textContent = `Quiz: ${currentElementData.nickname || 'Quiz'}`;
        renderQuestion(currentQuestionIndex);
        playerModal.classList.add('active');
    }

    function closeQuiz() {
         // This might be called if we add a cancel button, but typically quiz runs to completion.
         playerModal.classList.remove('active');
         clearSortableInstances();
         if (onQuizCompleteCallback) {
             console.log("Quiz closed/cancelled, triggering completion callback.");
             onQuizCompleteCallback(); // Ensure sequence advances even if cancelled
         }
    }


    function renderQuestion(index) {
        const question = currentQuiz.questions[index];
        if (!question) {
            console.error("Invalid question index:", index);
            return; // Should not happen
        }

        promptElement.innerHTML = `Q${index + 1}: ${question.prompt}`; // Use innerHTML to render potential basic formatting
        feedbackArea.innerHTML = ''; // Clear previous feedback
        feedbackArea.className = 'quiz-question-feedback-area'; // Reset feedback style
        answerArea.innerHTML = ''; // Clear previous answer area

        clearSortableInstances(); // Destroy previous drag/drop listeners before adding new ones

        // Render answer area based on type
        switch (question.questionType) {
            case 'multipleChoice':
                renderMultipleChoice(question);
                break;
            case 'fillBlank':
                renderFillBlank(question);
                break;
            case 'matching':
                renderMatching(question);
                break;
            case 'ordering':
                renderOrdering(question);
                break;
            default:
                answerArea.innerHTML = `<p>Error: Unsupported question type "${question.questionType}".</p>`;
        }

        // Update button text
        if (index === currentQuiz.questions.length - 1) {
            nextButton.textContent = 'Finish Quiz';
        } else {
            nextButton.textContent = 'Next Question';
        }
         nextButton.disabled = false; // Enable button when new question renders
    }

    // --- Rendering Specific Question Types ---

    function renderMultipleChoice(question) {
        const options = Utils.shuffleArray([...question.options]); // Shuffle a copy
        let html = `<div class="quiz-mc-options">`;
        options.forEach(opt => {
            // Use radio for single answer, checkbox if multiple correct allowed (assume single for now)
            html += `
                <label for="mc-opt-${opt.optionId}">
                    <input type="radio" name="mc-answer" id="mc-opt-${opt.optionId}" value="${opt.optionId}">
                    <span>${opt.text}</span>
                </label>
            `;
        });
        html += `</div>`;
        answerArea.innerHTML = html;
    }

     function renderFillBlank(question) {
        answerArea.innerHTML = `
            <div class="quiz-fillblank-input">
                <input type="text" id="fillblank-answer" placeholder="Type your answer here">
            </div>
        `;
     }

    function renderMatching(question) {
        // Shuffle prompts and answers separately
        const prompts = Utils.shuffleArray([...question.pairs.map(p => ({ id: p.pairId, text: p.prompt }))]);
        const answers = Utils.shuffleArray([...question.pairs.map(p => ({ id: p.pairId, text: p.answer }))]);

         // Store the correct mapping for checking later
         // We can reconstruct it from the original question.pairs if needed

        let html = `
            <p class="help-text">Drag the answers from the right to match the prompts on the left.</p>
            <div class="quiz-matching-area">
                <div class="quiz-matching-column" id="match-prompts-col">
                    <h4>Prompts</h4>
                    ${prompts.map(p => `
                        <div class="quiz-match-prompt" data-prompt-id="${p.id}">
                            <span>${p.text}</span>
                            <div class="quiz-match-drop-zone" data-pair-id="${p.id}">
                                <!-- Drop target -->
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div class="quiz-matching-column" id="match-answers-col">
                    <h4>Answers (Drag these)</h4>
                     ${answers.map(a => `
                        <div class="quiz-match-item" data-answer-id="${a.id}">
                            ${a.text}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        answerArea.innerHTML = html;

        // Initialize SortableJS
        const answersCol = document.getElementById('match-answers-col');
        const dropZones = document.querySelectorAll('.quiz-match-drop-zone');

        // Draggable answers pool
        sortableInstances.push(new Sortable(answersCol, {
            group: {
                name: 'matching',
                pull: 'clone', // Clone items when dragging out
                put: true // Allow items to be dropped back
            },
            sort: false, // Don't sort within the answer pool
            animation: 150,
            ghostClass: 'sortable-ghost',
            dragClass: 'sortable-drag'
        }));

        // Drop zones next to prompts
        dropZones.forEach(zone => {
           sortableInstances.push(new Sortable(zone, {
                group: {
                    name: 'matching',
                    put: true // Accept items
                },
                animation: 150,
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onAdd: function (evt) {
                    // Only allow one item per drop zone
                    if (zone.children.length > 1) {
                         // Move the previously dropped item back to the pool or the original zone?
                         // Easiest is to move the *newly* added one back if zone is full.
                        // Find the origin container (answersCol)
                        const origin = sortableInstances[0].el; // Assuming answersCol is the first instance
                        origin.appendChild(evt.item); // Move it back
                        // Or prevent drop entirely? Sortable's `put` function can do this.
                    }
                     // Maybe remove the "clone" status if we want it moved permanently?
                }
            }));
        });
    }

    function renderOrdering(question) {
        const items = Utils.shuffleArray([...question.items]); // Shuffle items for display

        let html = `
             <p class="help-text">Drag the items into the correct order below.</p>
             <div class="quiz-ordering-area" id="order-drop-area">
                 ${items.map((item, index) => `
                    <div class="quiz-order-item" data-original-index="${index}"> <!-- Store original index if needed? Or just text? -->
                        <span class="order-handle">☰</span> <!-- Drag handle -->
                        <span>${item}</span>
                    </div>
                 `).join('')}
             </div>
        `;
         answerArea.innerHTML = html;

         // Initialize SortableJS
         const dropArea = document.getElementById('order-drop-area');
         sortableInstances.push(new Sortable(dropArea, {
             animation: 150,
             ghostClass: 'sortable-ghost',
             dragClass: 'sortable-drag',
             handle: '.order-handle', // Specify drag handle
             // onEnd event not needed here unless we want to save state continuously
         }));
    }


    // --- Input Handling & Validation ---

    function handleNextButtonClick() {
        const question = currentQuiz.questions[currentQuestionIndex];
        let userAnswer = getUserAnswer(question);

        if (userAnswer === null) {
             // Indicate that an answer is required
             showFeedback("Please provide an answer.", "incorrect");
             return;
        }

        // Finalize answer and check correctness
        userAnswer.isCorrect = checkAnswer(question, userAnswer);
        userAnswers[question.questionId] = userAnswer; // Store the processed answer
        console.log("User Answer stored:", question.questionId, userAnswer);


        // --- Feedback Timing ---
        if (currentQuiz.feedbackTiming === 'each') {
            showFeedback(userAnswer.isCorrect ? "Correct!" : "Incorrect", userAnswer.isCorrect ? "correct" : "incorrect");
            disableInputs(question.questionType); // Disable input for this question
        }

        // --- Move to Next Question or Finish ---
        currentQuestionIndex++;
        if (currentQuestionIndex < currentQuiz.questions.length) {
            renderQuestion(currentQuestionIndex);
        } else {
            // Last question answered, move to finish/results
            finishQuiz();
        }
    }


    function getUserAnswer(question) {
        // Returns structured answer object or null if invalid/incomplete
        let answer = { answer: null }; // Basic structure
        try {
            switch (question.questionType) {
                case 'multipleChoice':
                    const selectedRadio = answerArea.querySelector('input[name="mc-answer"]:checked');
                    if (!selectedRadio) return null; // No selection
                    const selectedOptionId = selectedRadio.value;
                    const selectedOption = question.options.find(opt => opt.optionId === selectedOptionId);
                    answer.answer = selectedOptionId; // Store ID
                    answer.selectedText = selectedOption?.text; // Store text for results display
                    break;
                case 'fillBlank':
                    const textInput = document.getElementById('fillblank-answer');
                    if (!textInput || textInput.value.trim() === '') return null;
                    answer.answer = textInput.value;
                    answer.text = textInput.value; // Store raw text
                    break;
                case 'matching':
                    answer.answer = []; // Array of { promptId: ..., answerId: ... }
                    answer.matches = []; // Array of { prompt: ..., answer: ... } for display
                    const prompts = document.querySelectorAll('#match-prompts-col .quiz-match-prompt');
                    let allMatched = true;
                    prompts.forEach(promptDiv => {
                        const promptId = promptDiv.dataset.promptId;
                        const promptText = promptDiv.querySelector('span').textContent;
                        const dropZone = promptDiv.querySelector('.quiz-match-drop-zone');
                        const droppedItem = dropZone.querySelector('.quiz-match-item');
                        const answerId = droppedItem?.dataset.answerId || null;
                         const answerText = droppedItem?.textContent.trim() || null;

                        if (!answerId) allMatched = false; // Incomplete if any zone is empty

                        answer.answer.push({ promptId: promptId, answerId: answerId });
                         answer.matches.push({ prompt: promptText, answer: answerText });
                    });
                    if (!allMatched) return null; // Require all prompts to have a match attempted
                    break;
                case 'ordering':
                    const orderedItems = answerArea.querySelectorAll('#order-drop-area .quiz-order-item span:last-child');
                    if (orderedItems.length !== question.items.length) return null; // Should not happen
                    answer.answer = Array.from(orderedItems).map(span => span.textContent.trim());
                    answer.orderedItems = answer.answer; // Store for display
                    break;
                default: return null; // Unknown type
            }
            return answer;
        } catch (error) {
            console.error("Error getting user answer:", error);
            return null;
        }
    }

     function checkAnswer(question, userAnswer) {
         try {
            switch (question.questionType) {
                case 'multipleChoice':
                    const correctOption = question.options.find(opt => opt.isCorrect);
                    return userAnswer.answer === correctOption?.optionId;
                case 'fillBlank':
                    const correctAnswer = question.correctAnswer;
                    const userText = userAnswer.text;
                    if (question.caseSensitive) {
                        return userText === correctAnswer;
                    } else {
                        return userText.toLowerCase() === correctAnswer.toLowerCase();
                    }
                case 'matching':
                    // Check if every promptId is matched with the correct answerId
                    return userAnswer.answer.every(match => match.answerId === match.promptId);
                case 'ordering':
                    // Check if the user's order matches the defined correct order
                    if (userAnswer.answer.length !== question.items.length) return false;
                    return userAnswer.answer.every((item, index) => item === question.items[index]);
                default: return false;
            }
         } catch (error) {
             console.error("Error checking answer:", error);
             return false;
         }
     }

     function disableInputs(questionType) {
         nextButton.disabled = true; // Temporarily disable while showing feedback maybe? Or keep enabled? Let's keep enabled.

         switch (questionType) {
            case 'multipleChoice':
                answerArea.querySelectorAll('input[name="mc-answer"]').forEach(radio => radio.disabled = true);
                answerArea.querySelectorAll('label').forEach(label => label.classList.add('disabled'));
                break;
            case 'fillBlank':
                const textInput = document.getElementById('fillblank-answer');
                if (textInput) textInput.disabled = true;
                break;
            case 'matching':
                 // Disable drag/drop
                 clearSortableInstances(true); // Pass true to disable, not just destroy
                 answerArea.querySelectorAll('.quiz-match-item, .quiz-match-prompt').forEach(el => el.classList.add('disabled'));
                break;
            case 'ordering':
                 // Disable drag/drop
                 clearSortableInstances(true);
                 answerArea.querySelectorAll('.quiz-order-item').forEach(el => el.classList.add('disabled'));
                 answerArea.querySelectorAll('.order-handle').forEach(el => el.style.cursor = 'default');
                 break;
         }
     }

     function showFeedback(message, typeClass) { // typeClass = 'correct' or 'incorrect'
        feedbackArea.textContent = message;
        feedbackArea.className = `quiz-question-feedback-area ${typeClass}`; // Add class for styling
     }

    // --- Finishing and Results ---

    function finishQuiz() {
        console.log("Quiz finished. Calculating score...");
        playerModal.classList.remove('active'); // Close player modal
        clearSortableInstances();

        const score = calculateScore();
        console.log("Final Score:", score);

        // Handle feedback based on timing setting
        switch (currentQuiz.feedbackTiming) {
            case 'none':
                // No results shown, just complete the interaction
                 if (onQuizCompleteCallback) onQuizCompleteCallback();
                break;
            case 'each':
                // Feedback was shown after each question. Just complete.
                 if (onQuizCompleteCallback) onQuizCompleteCallback();
                break;
            case 'end':
                // Show results modal with score
                showResultsModal(score);
                // onQuizCompleteCallback is called when results modal is closed
                break;
            case 'emailUser':
            case 'emailCreator':
                 // Show results modal, which includes email logic/confirmation
                 showResultsModal(score);
                 // onQuizCompleteCallback is called when results modal is closed
                 break;
            default:
                 if (onQuizCompleteCallback) onQuizCompleteCallback(); // Failsafe
        }
    }

    function calculateScore() {
        let correctCount = 0;
        currentQuiz.questions.forEach(q => {
            if (userAnswers[q.questionId]?.isCorrect) {
                correctCount++;
            }
        });
        return { correct: correctCount, total: currentQuiz.questions.length };
    }

     function showResultsModal(score) {
         resultsScore.textContent = `Score: ${score.correct} / ${score.total}`;
         resultsEmailSection.style.display = 'none';
         resultsCreatorMessage.style.display = 'none';
         resultsEmailInput.value = '';
         resultsEmailStatus.textContent = '';
         resultsEmailStatusCreator.textContent = '';
         resultsSendButton.disabled = false;
         resultsEmailStatus.className = '';
         resultsEmailStatusCreator.className = '';


         if (currentQuiz.feedbackTiming === 'emailUser') {
             resultsEmailSection.style.display = 'block';
         } else if (currentQuiz.feedbackTiming === 'emailCreator') {
              resultsCreatorMessage.style.display = 'block';
              // Automatically send email in background? Or confirm? Let's auto-send.
              handleSendEmailToCreator(score);
         }

         resultsModal.classList.add('active');
     }

     function closeResultsModal() {
        resultsModal.classList.remove('active');
        // Trigger the completion callback *after* the results modal is closed
        if (onQuizCompleteCallback) {
             console.log("Results modal closed, triggering completion callback.");
             onQuizCompleteCallback();
        }
     }

    function prepareResultsPayload(score) {
        // Structure data for backend email function
        return {
            projectTitle: StateManager.getProjectTitle(), // Get project title from state
            quizTitle: currentElementData?.nickname || 'Quiz', // Get nickname of trigger element
            timestamp: quizStartTime ? new Date(quizStartTime).toISOString() : new Date().toISOString(),
            score: score,
            questions: currentQuiz.questions.map(q => ({ // Send question structure for context
                questionId: q.questionId,
                questionType: q.questionType,
                prompt: q.prompt
                // Don't send correct answers usually, unless needed for review email
            })),
            userAnswers: userAnswers // Send the recorded user answers (includes correctness)
        };
    }

    async function handleSendEmailToUser() {
        const userEmail = resultsEmailInput.value;
        if (!userEmail || !/\S+@\S+\.\S+/.test(userEmail)) {
            resultsEmailStatus.textContent = 'Please enter a valid email address.';
            resultsEmailStatus.className = 'error';
            return;
        }

        resultsSendButton.disabled = true;
        resultsEmailStatus.textContent = 'Sending...';
        resultsEmailStatus.className = 'info';

        try {
            const score = calculateScore(); // Recalculate or use stored score?
            const payload = prepareResultsPayload(score);
            await ServerClient.sendQuizToUser(payload, userEmail);
            resultsEmailStatus.textContent = 'Results sent successfully!';
            resultsEmailStatus.className = 'success';
             // Optionally close modal after a short delay?
             setTimeout(closeResultsModal, 1500);
        } catch (error) {
            console.error("Error sending email to user:", error);
            resultsEmailStatus.textContent = `Error: ${error.message}`;
            resultsEmailStatus.className = 'error';
            resultsSendButton.disabled = false; // Re-enable button on error
        }
    }

     async function handleSendEmailToCreator(score) {
         const creatorEmail = currentQuiz.creatorEmail;
          if (!creatorEmail || !/\S+@\S+\.\S+/.test(creatorEmail)) {
             resultsEmailStatusCreator.textContent = 'Error: Creator email address is invalid in quiz configuration.';
              resultsEmailStatusCreator.className = 'error';
             return; // Don't proceed
         }

         resultsEmailStatusCreator.textContent = 'Sending results to creator...';
          resultsEmailStatusCreator.className = 'info';

         try {
             const payload = prepareResultsPayload(score);
             // Add user info if possible/allowed (Apps Script session user)
             // The backend function Code.gs already does this.
             await ServerClient.sendQuizToCreator(payload, creatorEmail);
             resultsEmailStatusCreator.textContent = 'Results sent to creator.';
             resultsEmailStatusCreator.className = 'success';
         } catch (error) {
             console.error("Error sending email to creator:", error);
             resultsEmailStatusCreator.textContent = `Error sending: ${error.message}`;
              resultsEmailStatusCreator.className = 'error';
              // Don't disable close button
         }
     }


    // --- Utility ---
    function clearSortableInstances(disableOnly = false) {
        sortableInstances.forEach(instance => {
            if (disableOnly) {
                instance.option('disabled', true);
            } else {
                 try { instance.destroy(); } catch (e) { /* ignore if already destroyed */ }
            }
        });
         if (!disableOnly) {
            sortableInstances = [];
         }
    }


    // --- Public API ---
    _init(); // Initialize internal listeners
    return {
        openQuiz,
        // No explicit close needed, handled internally by finishQuiz or cancellation (if added)
        closeResultsModal // Allow closing results modal via button
    };

})();