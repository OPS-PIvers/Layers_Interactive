<script>
const EditorUI = (() => {
    let domRefs = {};
    let initAttempts = 0;
    const maxAttempts = 5;

    function init() {
        return new Promise((resolve, reject) => {
            try {
                initializeDOMReferences();
                initializeEventListeners();
                resolve();
            } catch (error) {
                console.error('EditorUI initialization error:', error);
                initAttempts++;
                
                if (initAttempts < maxAttempts) {
                    console.log(`Retrying EditorUI initialization in 100ms (attempt ${initAttempts}/${maxAttempts})`);
                    setTimeout(() => init().then(resolve).catch(reject), 100);
                } else {
                    reject(new Error('Failed to initialize EditorUI after multiple attempts'));
                }
            }
        });
    }

    function initializeDOMReferences() {
        // Define all required DOM elements
        const required = {
            propertiesPanel: 'properties-panel',
            toolbar: 'toolbar',
            slideList: 'slide-list',
            sequenceList: 'sequence-list',
            addSlideBtn: 'add-slide-button',
            deleteSlideBtn: 'delete-slide-button',
            saveBtn: 'save-button',
            undoBtn: 'undo-button',
            redoBtn: 'redo-button'
        };

        // Verify all required elements exist
        const missing = [];
        domRefs = {};

        for (const [key, id] of Object.entries(required)) {
            const element = document.getElementById(id);
            if (!element) {
                missing.push(id);
            } else {
                domRefs[key] = element;
            }
        }

        if (missing.length > 0) {
            throw new Error(`Missing required DOM elements: ${missing.join(', ')}`);
        }
    }

    function initializeEventListeners() {
        // Only attach listeners if we have valid DOM references
        if (!domRefs.addSlideBtn || !domRefs.deleteSlideBtn || !domRefs.saveBtn) {
            throw new Error('Cannot initialize event listeners: missing DOM references');
        }

        // Attach event listeners with error handling
        try {
            domRefs.addSlideBtn.addEventListener('click', handleAddSlide);
            domRefs.deleteSlideBtn.addEventListener('click', handleDeleteSlide);
            domRefs.saveBtn.addEventListener('click', handleSave);
            
            // Add undo/redo handlers
            if (domRefs.undoBtn && domRefs.redoBtn) {
                domRefs.undoBtn.addEventListener('click', handleUndo);
                domRefs.redoBtn.addEventListener('click', handleRedo);
            }

            // Initialize drag-drop for sequence list
            if (domRefs.sequenceList) {
                initializeSequenceListSorting();
            }
        } catch (error) {
            console.error('Error attaching event listeners:', error);
            throw error;
        }
    }

    let propertiesPanelContainer;
    let sequenceListContainer;
    let sequenceSortableInstance = null; // To manage SortableJS instance
    let slideListContainer;
    let currentSlideBgFilenameDisplay;
    let saveStatusDisplay;
    let projectTitleDisplay;
    let loadModal;
    let loadProjectListContainer;


    function _initDOMReferences() {
        propertiesPanelContainer = document.getElementById('element-properties-content');
        sequenceListContainer = document.getElementById('sequence-list');
        slideListContainer = document.getElementById('slide-list');
        currentSlideBgFilenameDisplay = document.getElementById('current-bg-filename');
        saveStatusDisplay = document.getElementById('save-status');
        projectTitleDisplay = document.getElementById('project-title-display');
        loadModal = document.getElementById('load-project-modal');
        loadProjectListContainer = document.getElementById('load-project-list');
    }

    function _initToolbar() {
        Utils.listen('#new-button', 'click', handleNewProject);
        Utils.listen('#save-button', 'click', handleSaveProject);
        Utils.listen('#load-button', 'click', handleShowLoadModal);
        Utils.listen('#add-rect-button', 'click', () => addShape('rect'));
        Utils.listen('#add-ellipse-button', 'click', () => addShape('ellipse'));
        Utils.listen('#add-text-button', 'click', () => addShape('textbox'));
        Utils.listen('#delete-button', 'click', CanvasController.deleteSelectedObject);

        // Add listener for project title editing? Maybe later.
        // projectTitleDisplay.onclick = handleEditTitle;
    }

    function _initSidebarTabs() {
        document.querySelectorAll('#sidebar-tabs .tab-link').forEach(button => {
            Utils.listen(button, 'click', (e) => {
                const targetTabId = e.target.dataset.tab;
                // Deactivate all tabs and content
                document.querySelectorAll('#sidebar-tabs .tab-link').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('#right-sidebar .sidebar-tab-content').forEach(content => content.classList.remove('active'));
                // Activate the clicked tab and corresponding content
                e.target.classList.add('active');
                document.getElementById(targetTabId)?.classList.add('active');
            });
        });
    }

    function _initSlideNavigator() {
        Utils.listen('#add-slide-button', 'click', handleAddSlide);
        Utils.listen('#delete-slide-button', 'click', handleDeleteSlide);
        Utils.listen('#upload-bg-button', 'click', () => document.getElementById('slide-bg-input').click());
        Utils.listen('#slide-bg-input', 'change', handleBackgroundUpload);

        updateSlideList();
        updateSlideBackgroundDisplay();
    }

    function _initSequenceList() {
        sequenceListContainer = document.getElementById('sequence-list');
        
        if (!sequenceListContainer) {
            console.error("Sequence list container not found. Will retry later.");
            // Setup a retry mechanism
            setTimeout(_initSequenceList, 500);
            return;
        }
        
        try {
            // Destroy previous instance if it exists
            if (sequenceSortableInstance) {
                sequenceSortableInstance.destroy();
            }
            
            // Initialize SortableJS
            sequenceSortableInstance = new Sortable(sequenceListContainer, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onStart: function(evt) {
                    // Add visual cue for dragging
                    evt.item.classList.add('dragging');
                },
                onEnd: function(evt) {
                    evt.item.classList.remove('dragging');
                    
                    // Safely get new sequence order
                    try {
                        const sequence = Array.from(evt.to.children)
                            .filter(item => item.dataset && item.dataset.elementId) // Ensure valid items only
                            .map(item => item.dataset.elementId);
                        
                        if (sequence.length > 0) {
                            StateManager.setSlideSequence(sequence);
                            console.log("Sequence updated:", sequence);
                        }
                    } catch (error) {
                        console.error("Error updating sequence:", error);
                    }
                },
            });
            
            updateSequenceList(); // Initial population
            console.log("Sequence list initialized successfully");
        } catch (error) {
            console.error("Error initializing sequence list:", error);
            // Maybe try again or show error
        }
    }


    // --- Event Handlers ---

    function handleNewProject() {
        if (StateManager.isDirty() && !confirm("You have unsaved changes. Are you sure you want to start a new project?")) {
            return;
        }
        StateManager.init(true); // Re-initialize state for editor
        CanvasController.loadSlide(StateManager.getCurrentSlide()); // Load the default slide
        updateSlideList();
        updateSequenceList();
        updatePropertiesPanel(null); // Clear properties panel
        updateProjectTitleDisplay();
        updateSaveStatus(StateManager.isDirty());
    }

    async function handleSaveProject() {
        const project = StateManager.getCurrentProject();
        if (!project) return;
        try {
             // Ensure current canvas state (like active selection props) is saved before stringifying
             const activeObj = CanvasController.getCanvas()?.getActiveObject();
             if (activeObj) {
                _savePropertiesFromUI(activeObj.id); // Force save current props if any are selected
             }

             const jsonString = StateManager.getProjectJsonString();
             const result = await ServerClient.saveProject(jsonString, project.projectId, project.title);
             StateManager.markAsSaved(result.projectId, result.lastModified); // Update state with new ID/status
             Utils.showError("Project saved successfully!"); // Use error modal as temp success message
             console.log("Project saved:", result);
        } catch (error) {
             console.error("Save failed:", error);
             Utils.showError(`Save failed: ${error.message}`);
             updateSaveStatus(true); // Still dirty if save failed
        }
    }

    async function handleShowLoadModal() {
         if (StateManager.isDirty() && !confirm("You have unsaved changes. Are you sure you want to load another project?")) {
            return;
        }
        loadModal.classList.add('active');
        loadProjectListContainer.innerHTML = '<p>Loading projects...</p>'; // Show loading state
        try {
            const projects = await ServerClient.listProjects();
            renderLoadProjectList(projects);
        } catch (error) {
             console.error("Failed to list projects:", error);
             loadProjectListContainer.innerHTML = `<p class="error-message">Error loading projects: ${error.message}</p>`;
        }
    }

    function closeLoadModal() {
        loadModal.classList.remove('active');
    }

    async function handleLoadProject(projectId) {
        closeLoadModal();
        if (!projectId) return;
         Utils.showLoadingIndicator(true, 'Loading Project...');
        try {
            const jsonString = await ServerClient.loadProject(projectId);
            if (StateManager.loadProjectData(jsonString)) {
                // Load succeeded
                 CanvasController.loadSlide(StateManager.getCurrentSlide());
                 updateSlideList();
                 updateSequenceList();
                 updatePropertiesPanel(null);
                 updateProjectTitleDisplay();
                 updateSaveStatus(false); // Loaded project is clean
            } else {
                // loadProjectData showed error via Utils.showError
            }
        } catch (error) {
            console.error("Load failed:", error);
            Utils.showError(`Load failed: ${error.message}`);
        } finally {
             Utils.showLoadingIndicator(false);
        }
    }


    function addShape(type) {
        const slide = StateManager.getCurrentSlide();
        if (!slide) return;

        const elementData = {
            type: type,
            id: Utils.generateUUID(),
            left: 50, top: 50, width: (type==='textbox'?150:100), height: (type==='textbox'?40:50), angle: 0,
            nickname: `${type.charAt(0).toUpperCase() + type.slice(1)} ${slide.elements.length + 1}`,
            initiallyHidden: false,
             // Add default nested structures immediately
             style: {
                color: type === 'textbox' ? 'rgba(0,0,0,0)' : '#4285F4', // Transparent background for text, blue for shapes
                opacity: 1,
                outlineEnabled: false,
                shadowEnabled: false,
             },
             text: type === 'textbox' ? {
                 content: 'New Text',
                 fontSize: 16,
                 fill: '#333333' // Default text color
             } : null,
             interactions: {
                 triggers: { onClick: false },
                 features: {
                     reveal: { enabled: false, targetIds: [] },
                     spotlight: { enabled: false, type: 'circle' },
                     panAndZoom: { enabled: false, targetX: 0, targetY: 0, targetZoom: 1.5 },
                     quiz: { enabled: false, feedbackTiming: 'end', creatorEmail: '', questions: [] }
                 }
             }
        };

        StateManager.addElementData(elementData);
        const fabricObject = CanvasController.addObject(elementData);
        if (fabricObject) {
            CanvasController.setActiveObject(fabricObject.id); // Select the new object
        }
         updateSequenceList(); // Update sequence panel if needed (though not in sequence yet)
    }

    function handleAddSlide() {
        const newSlideId = StateManager.addSlide();
        if (newSlideId) {
            StateManager.setCurrentSlideId(newSlideId);
            CanvasController.loadSlide(StateManager.getCurrentSlide());
            updateSlideList(); // Update UI list
            updateSequenceList(); // Clear sequence for new slide
            updatePropertiesPanel(null); // Clear properties
             updateSlideBackgroundDisplay(); // Update bg display
        }
    }

    function handleDeleteSlide() {
         const slideToDelete = StateManager.getCurrentSlide();
         if (!slideToDelete) return;
         if (confirm(`Are you sure you want to delete slide "${slideToDelete.title || slideToDelete.slideId}"? This cannot be undone.`)) {
             const currentId = slideToDelete.slideId;
             if (StateManager.deleteSlide(currentId)) {
                 // Deletion successful, state manager already switched slide if needed
                 const newCurrentSlide = StateManager.getCurrentSlide();
                 CanvasController.loadSlide(newCurrentSlide);
                 updateSlideList();
                 updateSequenceList();
                 updatePropertiesPanel(null);
                 updateSlideBackgroundDisplay();
             }
             // Error message handled by StateManager if deletion fails
         }
    }

    async function handleBackgroundUpload(event) {
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('image/')) {
            Utils.showError("Please select a valid image file.");
            return;
        }

        Utils.showLoadingIndicator(true, 'Reading Image...');
        const reader = new FileReader();
        reader.onload = async (e) => {
            const dataUrl = e.target.result;
            Utils.showLoadingIndicator(true, 'Uploading Image...'); // Switch message
            try {
                const result = await ServerClient.uploadImage(dataUrl, file.name);
                await CanvasController.setBackgroundImage(result.fileId); // Let CanvasController handle setting and updating state
                 updateSlideBackgroundDisplay(result.fileId, file.name);
            } catch (error) {
                 console.error("Background upload failed:", error);
                 Utils.showError(`Background upload failed: ${error.message}`);
            } finally {
                Utils.showLoadingIndicator(false);
                 event.target.value = null; // Reset file input
            }
        };
        reader.onerror = (e) => {
            Utils.showLoadingIndicator(false);
            Utils.showError("Failed to read image file.");
            event.target.value = null; // Reset file input
        };
        reader.readAsDataURL(file);
    }


    // --- UI Rendering ---

    function renderLoadProjectList(projects) {
         if (!projects || projects.length === 0) {
             loadProjectListContainer.innerHTML = '<p>No projects found.</p>';
             return;
         }
         const listHtml = `
            <ul>
                ${projects.map(p => `
                    <li onclick="EditorUI.handleLoadProject('${p.id}')">
                        <span class="project-title">${p.title || 'Untitled'}</span>
                        <span class="project-date">Modified: ${new Date(p.lastModified).toLocaleDateString()}</span>
                    </li>
                `).join('')}
            </ul>
         `;
         loadProjectListContainer.innerHTML = listHtml;
    }

    function updateSlideList() {
         if (!slideListContainer) return;
         const slides = StateManager.getSlides();
         const currentId = StateManager.getCurrentSlideId();
         slideListContainer.innerHTML = slides.map((slide, index) => `
            <li data-slide-id="${slide.slideId}" class="${slide.slideId === currentId ? 'active' : ''}" onclick="EditorUI.selectSlide('${slide.slideId}')">
                <!-- Add thumbnail later if possible -->
                <!-- <img src="placeholder.png" class="thumbnail"> -->
                <span>${index + 1}. ${slide.title || 'Untitled Slide'}</span>
            </li>
         `).join('');

         // Enable/disable delete button
         const deleteBtn = document.getElementById('delete-slide-button');
         if(deleteBtn) deleteBtn.disabled = slides.length <= 1;
    }

    function updateSlideBackgroundDisplay(fileId = null, filename = null) {
         if (!currentSlideBgFilenameDisplay) return;
         const slide = StateManager.getCurrentSlide();
         if (!slide) return;

         const currentFileId = fileId ?? slide.imageFileId; // Use passed ID or state ID

         if (currentFileId) {
             // Attempt to get a filename if not provided
             if (!filename) {
                 // Maybe store filename in slide data? For now, use ID.
                 filename = `Image ID: ${currentFileId}`;
             }
             currentSlideBgFilenameDisplay.textContent = filename;
             currentSlideBgFilenameDisplay.title = filename; // Tooltip for long names
         } else {
            currentSlideBgFilenameDisplay.textContent = "No background image set";
            currentSlideBgFilenameDisplay.title = "";
         }
    }

    function selectSlide(slideId) {
        if (slideId === StateManager.getCurrentSlideId()) return; // No change
        StateManager.setCurrentSlideId(slideId);
        CanvasController.loadSlide(StateManager.getCurrentSlide());
        updateSlideList(); // Re-render list to show active state
        updateSequenceList(); // Update sequence for the new slide
        updatePropertiesPanel(null); // Clear properties panel
        updateSlideBackgroundDisplay(); // Update background info display
    }

    function updateSequenceList() {
        if (!sequenceListContainer) return;
        const slide = StateManager.getCurrentSlide();
        const sequence = slide?.sequence || [];
        const elements = slide?.elements || [];

        if (sequence.length === 0) {
            sequenceListContainer.innerHTML = '<li class="placeholder-item">No elements in sequence. Add elements and enable interactions.</li>';
            return;
        }

        sequenceListContainer.innerHTML = sequence.map(elementId => {
            const element = elements.find(el => el.id === elementId);
            const nickname = element?.nickname || elementId;
            const type = element?.type || 'Unknown';
             // Check if element actually exists - might be orphaned ID
            if (!element) {
                 return `<li data-element-id="${elementId}" class="orphaned">
                            <span class="element-nickname">⚠ Orphaned ID: ${elementId}</span>
                            <button class="remove-orphan-btn" onclick="EditorUI.removeOrphanFromSequence('${elementId}')">Remove</button>
                        </li>`;
            }
            return `<li data-element-id="${elementId}">
                        <span class="element-nickname">${nickname}</span>
                        <span class="element-type">(${type})</span>
                    </li>`;
        }).join('');
    }

    function removeOrphanFromSequence(elementId) {
        if (confirm(`Remove orphaned ID "${elementId}" from sequence?`)) {
            const currentSequence = StateManager.getSlideSequence();
            const newSequence = currentSequence.filter(id => id !== elementId);
            StateManager.setSlideSequence(newSequence);
            updateSequenceList(); // Re-render the list
        }
    }


    function updatePropertiesPanel(fabricObject) {
        if (!domRefs.propertiesPanel) return;
        
        try {
            // Clear existing panel content
            domRefs.propertiesPanel.innerHTML = '';
            
            if (!fabricObject) {
                domRefs.propertiesPanel.innerHTML = '<p class="no-selection">No element selected</p>';
                return;
            }

            const elementData = StateManager.getElementData(fabricObject.id);
            if (!elementData) {
                console.error('No state data found for selected object:', fabricObject.id);
                return;
            }

            // Generate and append properties form
            const form = generatePropertiesForm(elementData, fabricObject);
            domRefs.propertiesPanel.appendChild(form);
        } catch (error) {
            console.error('Error updating properties panel:', error);
            Utils.showError('Failed to update properties panel');
        }
    }

    function _attachPropertiesPanelListeners(elementId) {
         // Use event delegation? Or direct listeners? Direct might be simpler here.
         // Debounce input listeners to avoid excessive updates
         const debounceRate = 300; // ms
         const debouncedSave = Utils.debounce(() => _savePropertiesFromUI(elementId), debounceRate);

         // Identification
         Utils.listen('#prop-nickname', 'input', debouncedSave);

         // Transform
         Utils.listen('#prop-left', 'input', debouncedSave);
         Utils.listen('#prop-top', 'input', debouncedSave);
         Utils.listen('#prop-width', 'input', debouncedSave);
         Utils.listen('#prop-height', 'input', debouncedSave);
         Utils.listen('#prop-angle', 'input', debouncedSave);

         // Style
         Utils.listen('#prop-style-color', 'input', debouncedSave);
         Utils.listen('#prop-style-opacity', 'input', debouncedSave);
         // Outline
         Utils.listen('#prop-style-outlineEnabled', 'change', () => { _toggleFieldsetEnable('#prop-style-outlineEnabled', ['#prop-style-outlineColor', '#prop-style-outlineWidth']); debouncedSave(); });
         Utils.listen('#prop-style-outlineColor', 'input', debouncedSave);
         Utils.listen('#prop-style-outlineWidth', 'input', debouncedSave);
         // Shadow
          Utils.listen('#prop-style-shadowEnabled', 'change', () => { _toggleFieldsetEnable('#prop-style-shadowEnabled', ['#prop-style-shadowColor', '#prop-style-shadowBlur', '#prop-style-shadowOffsetX', '#prop-style-shadowOffsetY']); debouncedSave(); });
         Utils.listen('#prop-style-shadowColor', 'input', debouncedSave);
         Utils.listen('#prop-style-shadowBlur', 'input', debouncedSave);
         Utils.listen('#prop-style-shadowOffsetX', 'input', debouncedSave);
         Utils.listen('#prop-style-shadowOffsetY', 'input', debouncedSave);

         // Text (if exists)
          if (document.getElementById('prop-text-content')) {
              Utils.listen('#prop-text-content', 'input', debouncedSave);
              Utils.listen('#prop-text-fontSize', 'input', debouncedSave);
              Utils.listen('#prop-text-fill', 'input', debouncedSave);
          }

          // Interactions
          Utils.listen('#prop-trigger-onClick', 'change', debouncedSave);
          // Features
          Utils.listen('#prop-feature-revealEnabled', 'change', debouncedSave);
          Utils.listen('#prop-feature-spotlightEnabled', 'change', debouncedSave);
          Utils.listen('#prop-feature-panZoomEnabled', 'change', debouncedSave);
          // Quiz Feature specific
           Utils.listen('#prop-feature-quizEnabled', 'change', (e) => {
                document.getElementById('quiz-config-section')?.classList.toggle('hidden', !e.target.checked);
                debouncedSave();
                updateSequenceList(); // Re-render sequence as quiz status affects display? maybe later
           });
          Utils.listen('#prop-quiz-feedbackTiming', 'change', (e) => {
               document.getElementById('quiz-creator-email-group')?.classList.toggle('hidden', e.target.value !== 'emailCreator');
               debouncedSave();
          });
          Utils.listen('#prop-quiz-creatorEmail', 'input', debouncedSave);
          Utils.listen('#edit-quiz-content-button', 'click', () => {
                const data = StateManager.getElementData(elementId);
                if (data && data.interactions?.features?.quiz) {
                    QuizEditor.open(data.interactions.features.quiz, elementId); // Pass quiz data and element ID
                }
          });

          // Initial State
          Utils.listen('#prop-initiallyHidden', 'change', debouncedSave);
    }

    // Helper to enable/disable fields based on a checkbox
     function _toggleFieldsetEnable(checkboxSelector, fieldsToToggleSelectors) {
        const isChecked = document.querySelector(checkboxSelector)?.checked;
        fieldsToToggleSelectors.forEach(selector => {
            const field = document.querySelector(selector);
            if (field) field.disabled = !isChecked;
        });
     }

    function _savePropertiesFromUI(elementId) {
        const elementData = StateManager.getElementData(elementId);
        if (!elementData) {
            console.error(`Element data not found for ID: ${elementId}`);
            return false;
        }

        try {
            const updates = {
                nickname: document.getElementById('prop-nickname')?.value || elementData.nickname,
                left: parseFloat(document.getElementById('prop-left')?.value || elementData.left) || 0,
                top: parseFloat(document.getElementById('prop-top')?.value || elementData.top) || 0,
                width: parseFloat(document.getElementById('prop-width')?.value || elementData.width) || 100,
                height: parseFloat(document.getElementById('prop-height')?.value || elementData.height) || 50,
                angle: parseFloat(document.getElementById('prop-angle')?.value || elementData.angle) || 0,
                initiallyHidden: document.getElementById('prop-initiallyHidden')?.checked || false,
                
                // Create a deep copy of nested objects to avoid reference issues
                style: {
                    color: document.getElementById('prop-style-color')?.value || '#FFFFFF',
                    opacity: parseFloat(document.getElementById('prop-style-opacity')?.value ?? 1.0),
                    outlineEnabled: document.getElementById('prop-style-outlineEnabled')?.checked || false,
                    outlineColor: document.getElementById('prop-style-outlineColor')?.value || '#000000',
                    outlineWidth: parseInt(document.getElementById('prop-style-outlineWidth')?.value || 1),
                    shadowEnabled: document.getElementById('prop-style-shadowEnabled')?.checked || false,
                    shadowColor: document.getElementById('prop-style-shadowColor')?.value || '#000000',
                    shadowBlur: parseInt(document.getElementById('prop-style-shadowBlur')?.value || 5),
                    shadowOffsetX: parseInt(document.getElementById('prop-style-shadowOffsetX')?.value || 0),
                    shadowOffsetY: parseInt(document.getElementById('prop-style-shadowOffsetY')?.value || 0),
                },
                
                // Only update text properties for textbox elements
                text: elementData.type === 'textbox' ? {
                    content: document.getElementById('prop-text-content')?.value || '',
                    fontSize: parseInt(document.getElementById('prop-text-fontSize')?.value || 16),
                    fill: document.getElementById('prop-text-fill')?.value || '#333333',
                } : elementData.text,
                
                // Keep nested structure consistent
                interactions: {
                    triggers: {
                        onClick: document.getElementById('prop-trigger-onClick')?.checked || false,
                    },
                    features: {
                        // Create deep copies to avoid reference issues
                        reveal: {
                            enabled: document.getElementById('prop-feature-revealEnabled')?.checked || false,
                            targetIds: elementData.interactions?.features?.reveal?.targetIds || [],
                        },
                        spotlight: {
                            enabled: document.getElementById('prop-feature-spotlightEnabled')?.checked || false,
                            type: elementData.interactions?.features?.spotlight?.type || 'circle',
                        },
                        panAndZoom: {
                            enabled: document.getElementById('prop-feature-panZoomEnabled')?.checked || false,
                            targetX: elementData.interactions?.features?.panAndZoom?.targetX || 0,
                            targetY: elementData.interactions?.features?.panAndZoom?.targetY || 0,
                            targetZoom: elementData.interactions?.features?.panAndZoom?.targetZoom || 1.5,
                        },
                        quiz: {
                            // Preserve existing quiz data structure
                            ...(elementData.interactions?.features?.quiz || { questions: [] }),
                            enabled: document.getElementById('prop-feature-quizEnabled')?.checked || false,
                            feedbackTiming: document.getElementById('prop-quiz-feedbackTiming')?.value || 'end',
                            creatorEmail: document.getElementById('prop-quiz-creatorEmail')?.value || '',
                        }
                    }
                }
            };

            // Apply updates to StateManager
            const success = StateManager.updateElementData(elementId, updates);
            
            if (success) {
                // Update the Fabric object to match the new state
                CanvasController.updateObjectFromData(elementId);
                
                // Update sequence list for nickname changes
                updateSequenceList();
                
                // Update quiz button text
                const quizButton = document.getElementById('edit-quiz-content-button');
                if (quizButton) {
                    const qCount = updates.interactions.features.quiz.questions?.length || 0;
                    quizButton.textContent = `Edit Quiz Content (${qCount} Qs)`;
                }
                
                return true;
            }
            return false;
        } catch (error) {
            console.error(`Error saving properties for element ${elementId}:`, error);
            Utils.showError(`Failed to save properties: ${error.message}`);
            return false;
        }
    }


    function updateToolbarState(isObjectSelected) {
        const deleteBtn = document.getElementById('delete-button');
        if (deleteBtn) {
            deleteBtn.disabled = !isObjectSelected;
        }
        // Add logic for other buttons (e.g., group/ungroup) later
    }

    function updateSaveStatus(isDirty, lastModified = null) {
        if (!saveStatusDisplay) return;
        if (isDirty) {
            saveStatusDisplay.textContent = '* Unsaved Changes';
            saveStatusDisplay.style.color = 'orange';
        } else {
             const timestamp = lastModified ? `Saved: ${new Date(lastModified).toLocaleTimeString()}` : 'Saved';
             saveStatusDisplay.textContent = timestamp;
             saveStatusDisplay.style.color = 'var(--secondary-color)'; // Green
        }
    }

    function updateProjectTitleDisplay() {
        if (projectTitleDisplay) {
             projectTitleDisplay.textContent = StateManager.getProjectTitle() || 'Untitled Project';
             // Optionally add ID if it exists:
             // const projId = StateManager.getProjectId();
             // if (projId) projectTitleDisplay.textContent += ` (${projId.substring(0, 6)}...)`;
        }
    }

    // --- Public API ---
    return {
      initEditorUI() {
        _initDOMReferences();
        _initToolbar();
        _initSidebarTabs();
        _initSlideNavigator();
        _initSequenceList();
        updatePropertiesPanel(null); // Initial state (no selection)
        updateToolbarState(false);
        updateProjectTitleDisplay();
        updateSaveStatus(StateManager.isDirty()); // Initial save status
        console.log("Editor UI Initialized.");
      },
      updatePropertiesPanel, // Expose for CanvasController
      updateSequenceList,    // Expose for StateManager changes if needed
      updateSlideList,       // Expose for StateManager changes
      updateSlideBackgroundDisplay, // Expose for CanvasController
      updateToolbarState, // Expose for CanvasController selection
      updateSaveStatus, // Expose for StateManager/ServerClient
      updateProjectTitleDisplay, // Expose for StateManager
      selectSlide, // Allow selecting slide programmatically if needed
      handleLoadProject, // Allow triggering load from modal list
      closeLoadModal, // Allow closing modal
      removeOrphanFromSequence // Expose for button click
    };

})();
</script>