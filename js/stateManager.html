<script>
const StateManager = (() => {
    let currentProject = null;
    let currentSlideId = null;
    let isDirtyFlag = false;
    let sequenceActive = false;
    let currentSequenceIndex = -1;
    let actionHistory = [];
    let subscribers = new Map();

    function init(resetData = false) {
        if (resetData) {
            currentProject = createNewProject();
            currentSlideId = currentProject.slides[0].slideId;
            isDirtyFlag = false;
            sequenceActive = false;
            currentSequenceIndex = -1;
            actionHistory = [];
        }
        notifySubscribers('projectChanged');
    }

    // Subscribe to state changes
    function subscribe(eventType, callback) {
        if (!subscribers.has(eventType)) {
            subscribers.set(eventType, new Set());
        }
        subscribers.get(eventType).add(callback);
        return () => unsubscribe(eventType, callback);
    }

    function unsubscribe(eventType, callback) {
        if (subscribers.has(eventType)) {
            subscribers.get(eventType).delete(callback);
        }
    }

    function notifySubscribers(eventType, data) {
        if (subscribers.has(eventType)) {
            subscribers.get(eventType).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in subscriber callback for ${eventType}:`, error);
                }
            });
        }
    }

    // Project state management
    function createNewProject() {
        return {
            projectId: null,
            title: 'Untitled Project',
            lastModified: Date.now(),
            slides: [{
                slideId: Utils.generateUUID(),
                title: 'Slide 1',
                elements: [],
                sequence: [],
                backgroundColor: '#FFFFFF',
                imageFileId: null
            }],
            viewerSettings: {
                enablePrevNext: true,
                allowSkip: false,
                showProgress: true
            }
        };
    }

    function updateElementData(elementId, updates) {
        if (!currentProject || !currentSlideId) return false;
        
        try {
            const slide = getCurrentSlide();
            if (!slide) return false;

            const elementIndex = slide.elements.findIndex(el => el.id === elementId);
            if (elementIndex === -1) return false;

            // Create a new element object with updates
            const updatedElement = {
                ...slide.elements[elementIndex],
                ...updates,
                // Handle nested objects carefully
                style: { ...slide.elements[elementIndex].style, ...(updates.style || {}) },
                interactions: {
                    ...slide.elements[elementIndex].interactions,
                    ...(updates.interactions || {}),
                    // Preserve nested feature structure
                    features: {
                        ...slide.elements[elementIndex].interactions?.features,
                        ...(updates.interactions?.features || {})
                    }
                }
            };

            // Update the elements array
            slide.elements[elementIndex] = updatedElement;
            
            setDirty(true);
            notifySubscribers('elementChanged', { elementId, updates });
            return true;
        } catch (error) {
            console.error('Error updating element data:', error);
            return false;
        }
    }

    function getElementData(elementId) {
        const slide = getCurrentSlide();
        return slide?.elements.find(el => el.id === elementId);
    }

    function addElementData(elementData) {
        if (!currentProject || !currentSlideId) return false;
        
        const slide = getCurrentSlide();
        if (!slide) return false;

        // Ensure required properties exist
        if (!elementData.id) elementData.id = Utils.generateUUID();
        
        slide.elements.push(elementData);
        setDirty(true);
        notifySubscribers('elementAdded', elementData);
        return elementData.id;
    }

    function removeElementData(elementId) {
        if (!currentProject || !currentSlideId) return false;
        
        const slide = getCurrentSlide();
        if (!slide) return false;

        const index = slide.elements.findIndex(el => el.id === elementId);
        if (index === -1) return false;

        // Remove from elements array
        slide.elements.splice(index, 1);
        
        // Also remove from sequence if present
        const seqIndex = slide.sequence.indexOf(elementId);
        if (seqIndex !== -1) {
            slide.sequence.splice(seqIndex, 1);
        }

        setDirty(true);
        notifySubscribers('elementRemoved', elementId);
        return true;
    }

    // Slide management
    function getCurrentSlide() {
        return currentProject?.slides.find(s => s.slideId === currentSlideId);
    }

    function getSlides() {
        return currentProject?.slides || [];
    }

    function setCurrentSlideId(slideId) {
        if (!currentProject) return false;
        const slide = currentProject.slides.find(s => s.slideId === slideId);
        if (!slide) return false;

        currentSlideId = slideId;
        notifySubscribers('slideChanged', slideId);
        return true;
    }

    function addSlide() {
        if (!currentProject) return null;
        
        const newSlide = {
            slideId: Utils.generateUUID(),
            title: `Slide ${currentProject.slides.length + 1}`,
            elements: [],
            sequence: [],
            backgroundColor: '#FFFFFF',
            imageFileId: null
        };

        currentProject.slides.push(newSlide);
        setDirty(true);
        notifySubscribers('slideAdded', newSlide);
        return newSlide.slideId;
    }

    function deleteSlide(slideId) {
        if (!currentProject || currentProject.slides.length <= 1) return false;

        const index = currentProject.slides.findIndex(s => s.slideId === slideId);
        if (index === -1) return false;

        currentProject.slides.splice(index, 1);
        
        // If we deleted the current slide, switch to another one
        if (slideId === currentSlideId) {
            currentSlideId = currentProject.slides[Math.max(0, index - 1)].slideId;
        }

        setDirty(true);
        notifySubscribers('slideRemoved', { slideId, newCurrentId: currentSlideId });
        return true;
    }

    // Sequence management
    function getCurrentSequenceIndex() {
        return currentSequenceIndex;
    }

    function getCurrentSequence() {
        return getCurrentSlide()?.sequence || [];
    }

    function setCurrentSequenceIndex(index) {
        currentSequenceIndex = index;
        notifySubscribers('sequenceIndexChanged', index);
    }

    function startSequence() {
        sequenceActive = true;
        currentSequenceIndex = 0;
        notifySubscribers('sequenceStarted');
    }

    function stopSequence() {
        sequenceActive = false;
        currentSequenceIndex = -1;
        notifySubscribers('sequenceStopped');
    }

    function isSequenceActive() {
        return sequenceActive;
    }

    function setSlideSequence(sequence) {
        const slide = getCurrentSlide();
        if (!slide) return false;

        slide.sequence = [...sequence];
        setDirty(true);
        notifySubscribers('sequenceUpdated', sequence);
        return true;
    }

    // Action history for undo/redo
    function addActionToHistory(action) {
        actionHistory.push(action);
        notifySubscribers('historyUpdated', actionHistory);
    }

    function getActionHistory() {
        return [...actionHistory];
    }

    function clearActionHistory() {
        actionHistory = [];
        notifySubscribers('historyCleared');
    }

    // Project state
    function isDirty() {
        return isDirtyFlag;
    }

    function setDirty(value) {
        isDirtyFlag = value;
        notifySubscribers('dirtyStateChanged', value);
    }

    function markAsSaved(projectId, timestamp) {
        if (currentProject) {
            currentProject.projectId = projectId;
            currentProject.lastModified = timestamp;
        }
        setDirty(false);
    }

    // Project serialization
    function getProjectJsonString() {
        return JSON.stringify(currentProject);
    }

    function loadProjectData(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            if (!validateProjectData(data)) {
                throw new Error('Invalid project data structure');
            }
            
            currentProject = data;
            currentSlideId = data.slides[0].slideId;
            isDirtyFlag = false;
            sequenceActive = false;
            currentSequenceIndex = -1;
            actionHistory = [];
            
            notifySubscribers('projectLoaded', data);
            return true;
        } catch (error) {
            console.error('Error loading project data:', error);
            Utils.showError(`Failed to load project: ${error.message}`);
            return false;
        }
    }

    // Data validation
    function validateProjectData(data) {
        // Basic structure check
        if (!data || !Array.isArray(data.slides) || data.slides.length === 0) {
            return false;
        }

        // Check each slide has required properties
        for (const slide of data.slides) {
            if (!slide.slideId || !Array.isArray(slide.elements) || !Array.isArray(slide.sequence)) {
                return false;
            }
        }

        return true;
    }

    return {
        init,
        subscribe,
        unsubscribe,
        getCurrentSlide,
        getSlides,
        getCurrentSlideId: () => currentSlideId,
        setCurrentSlideId,
        addSlide,
        deleteSlide,
        updateElementData,
        getElementData,
        addElementData,
        removeElementData,
        getCurrentSequenceIndex,
        getCurrentSequence,
        setCurrentSequenceIndex,
        startSequence,
        stopSequence,
        isSequenceActive,
        setSlideSequence,
        addActionToHistory,
        getActionHistory,
        clearActionHistory,
        isDirty,
        setDirty,
        markAsSaved,
        getProjectJsonString,
        loadProjectData,
        getProjectTitle: () => currentProject?.title || 'Untitled Project',
        getProjectId: () => currentProject?.projectId,
        getViewerSettings: () => currentProject?.viewerSettings || { enablePrevNext: true, allowSkip: false, showProgress: true }
    };
})();
</script>