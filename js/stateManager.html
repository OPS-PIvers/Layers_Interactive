<script>
    /**
     * Manages application state and data
     */
    const StateManager = (() => {
      // Current project data
      let currentProject = null;
      
      // Current selected items
      let currentSlideId = null;
      let currentSequenceIndex = -1;
      
      // Action history for undo/redo
      let actionHistory = [];
      
      // View state (editor or viewer)
      let isEditorMode = true;
      
      // Track whether project has unsaved changes
      let projectDirty = false;
      let lastSavedProjectData = null;
      
      /**
       * Initialize state manager
       * @param {boolean} editorMode - Whether in editor mode
       */
      function init(editorMode = true) {
        currentProject = null;
        currentSlideId = null;
        currentSequenceIndex = -1;
        actionHistory = [];
        isEditorMode = editorMode;
        projectDirty = false;
        lastSavedProjectData = null;
        
        // Create empty project if in editor mode
        if (editorMode) {
          createNewProject();
        }
      }
      
      /**
       * Create a new empty project
       */
      function createNewProject() {
        currentProject = {
          projectId: null,
          title: 'Untitled Project',
          createdAt: Date.now(),
          modifiedAt: Date.now(),
          slides: []
        };
        
        // Create initial slide
        const slideId = createSlide();
        setCurrentSlideId(slideId);
        
        // New project is dirty until saved for the first time
        projectDirty = true;
      }
      
      /**
       * Create a new slide
       * @param {string} type - Slide type (image, youtube)
       * @return {string} Slide ID
       */
      function createSlide(type = 'image') {
        if (!currentProject) return null;
        
        const slideId = Utils.generateId('slide-');
        const newSlide = {
          slideId,
          slideType: type,
          title: `Slide ${currentProject.slides.length + 1}`,
          backgroundColor: '#FFFFFF',
          elements: [],
          sequence: []
        };
        
        // Add slide-type specific properties
        if (type === 'youtube') {
          newSlide.youtubeVideoId = '';
          newSlide.overlayTimings = [];
        }
        
        currentProject.slides.push(newSlide);
        projectDirty = true;
        return slideId;
      }
      
      /**
       * Load project data from JSON string
       * @param {string} jsonString - Project data as JSON string
       * @return {boolean} Success
       */
      function loadProjectData(jsonString) {
        try {
          currentProject = JSON.parse(jsonString);
          
          // Set first slide as current if available
          if (currentProject.slides && currentProject.slides.length > 0) {
            setCurrentSlideId(currentProject.slides[0].slideId);
          } else {
            currentSlideId = null;
          }
          
          // Reset sequence index
          currentSequenceIndex = -1;
          actionHistory = [];
          
          // Store a copy of the loaded data to compare for dirty state
          lastSavedProjectData = jsonString;
          projectDirty = false;
          
          return true;
        } catch (error) {
          console.error('Error parsing project data:', error);
          return false;
        }
      }
      
      /**
       * Get project data as JSON string
       * @return {string} Project data as JSON string
       */
      function getProjectJsonString() {
        if (!currentProject) return null;
        return JSON.stringify(currentProject, null, 2);
      }
      
      /**
       * Get current project
       * @return {Object} Current project
       */
      function getCurrentProject() {
        return currentProject;
      }
      
      /**
       * Get project title
       * @return {string} Project title
       */
      function getProjectTitle() {
        return currentProject ? currentProject.title : 'Untitled Project';
      }
      
      /**
       * Get project ID
       * @return {string} Project ID
       */
      function getProjectId() {
        return currentProject ? currentProject.projectId : null;
      }
      
      /**
       * Get current slide
       * @return {Object} Current slide
       */
      function getCurrentSlide() {
        if (!currentProject || !currentSlideId) return null;
        return currentProject.slides.find(s => s.slideId === currentSlideId);
      }
      
      /**
       * Get all slides
       * @return {Array} All slides
       */
      function getSlides() {
        return currentProject ? currentProject.slides : [];
      }
      
      /**
       * Get current slide ID
       * @return {string} Current slide ID
       */
      function getCurrentSlideId() {
        return currentSlideId;
      }
      
      /**
       * Set current slide ID
       * @param {string} slideId - Slide ID
       */
      function setCurrentSlideId(slideId) {
        currentSlideId = slideId;
        currentSequenceIndex = -1;
        actionHistory = [];
      }
      
      /**
       * Update slide properties
       * @param {string} slideId - Slide ID
       * @param {Object} properties - Properties to update
       * @return {boolean} Success
       */
      function updateSlideProperties(slideId, properties) {
        if (!currentProject) return false;
        
        const slideIndex = currentProject.slides.findIndex(s => s.slideId === slideId);
        if (slideIndex === -1) return false;
        
        currentProject.slides[slideIndex] = {
          ...currentProject.slides[slideIndex],
          ...properties
        };
        
        projectDirty = true;
        return true;
      }
      
      /**
       * Get element data by ID
       * @param {string} elementId - Element ID
       * @return {Object} Element data
       */
      function getElementData(elementId) {
        const slide = getCurrentSlide();
        if (!slide) return null;
        
        return slide.elements.find(el => el.id === elementId);
      }
      
      /**
       * Add element data
       * @param {Object} elementData - Element data
       * @return {string} Element ID
       */
      function addElementData(elementData) {
        const slide = getCurrentSlide();
        if (!slide) return null;
        
        // Create ID if not provided
        const elementId = elementData.id || Utils.generateId('element-');
        
        // Ensure element has an ID
        const newElement = {
          ...elementData,
          id: elementId,
          createdAt: Date.now()
        };
        
        // Add to slide elements
        slide.elements.push(newElement);
        projectDirty = true;
        
        return elementId;
      }
      
      /**
       * Update element data
       * @param {string} elementId - Element ID
       * @param {Object} newData - Data to update
       * @return {boolean} Success
       */
      function updateElementData(elementId, newData) {
        const slide = getCurrentSlide();
        if (!slide) return false;
        
        const elementIndex = slide.elements.findIndex(el => el.id === elementId);
        if (elementIndex === -1) return false;
        
        // Deep merge the objects (simple approach)
        slide.elements[elementIndex] = deepMerge(slide.elements[elementIndex], newData);
        projectDirty = true;
        
        return true;
      }
      
      /**
       * Deep merge two objects
       * @param {Object} target - Target object
       * @param {Object} source - Source object
       * @return {Object} Merged object
       */
      function deepMerge(target, source) {
        const output = { ...target };
        
        if (isObject(target) && isObject(source)) {
          Object.keys(source).forEach(key => {
            if (isObject(source[key])) {
              if (!(key in target)) {
                output[key] = source[key];
              } else {
                output[key] = deepMerge(target[key], source[key]);
              }
            } else {
              output[key] = source[key];
            }
          });
        }
        
        return output;
      }
      
      /**
       * Check if value is an object
       * @param {*} item - Value to check
       * @return {boolean} Whether value is an object
       */
      function isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item);
      }
      
      /**
       * Remove element data
       * @param {string} elementId - Element ID
       * @return {boolean} Success
       */
      function removeElementData(elementId) {
        const slide = getCurrentSlide();
        if (!slide) return false;
        
        // Remove from elements array
        slide.elements = slide.elements.filter(el => el.id !== elementId);
        
        // Remove from sequence array
        slide.sequence = slide.sequence.filter(id => id !== elementId);
        
        // Remove from overlay timings if YouTube slide
        if (slide.slideType === 'youtube' && slide.overlayTimings) {
          slide.overlayTimings = slide.overlayTimings.filter(timing => timing.elementId !== elementId);
        }
        
        projectDirty = true;
        return true;
      }
      
      /**
       * Add a slide
       * @param {string} type - Slide type
       * @return {string} New slide ID
       */
      function addSlide(type = 'image') {
        if (!currentProject) return null;
        
        const slideId = createSlide(type);
        projectDirty = true;
        return slideId;
      }
      
      /**
       * Delete a slide
       * @param {string} slideId - Slide ID to delete
       * @return {boolean} Success
       */
      function deleteSlide(slideId) {
        if (!currentProject || !slideId) return false;
        
        // Check if this is the only slide
        if (currentProject.slides.length <= 1) {
          Utils.showError("Cannot delete the only slide in the project.");
          return false;
        }
        
        // Find slide index
        const slideIndex = currentProject.slides.findIndex(s => s.slideId === slideId);
        if (slideIndex === -1) {
          return false;
        }
        
        // Remove slide
        currentProject.slides.splice(slideIndex, 1);
        
        // If we deleted the current slide, set a new current slide
        if (slideId === currentSlideId) {
          const newIndex = Math.min(slideIndex, currentProject.slides.length - 1);
          currentSlideId = currentProject.slides[newIndex].slideId;
        }
        
        projectDirty = true;
        return true;
      }
      
      /**
       * Get slide sequence
       * @return {Array} Sequence of element IDs
       */
      function getSlideSequence() {
        const slide = getCurrentSlide();
        return slide ? slide.sequence : [];
      }
      
      /**
       * Set slide sequence
       * @param {Array} sequence - Sequence of element IDs
       * @return {boolean} Success
       */
      function setSlideSequence(sequence) {
        const slide = getCurrentSlide();
        if (!slide) return false;
        
        slide.sequence = sequence;
        projectDirty = true;
        return true;
      }
      
      /**
       * Get current sequence index
       * @return {number} Sequence index
       */
      function getCurrentSequenceIndex() {
        return currentSequenceIndex;
      }
      
      /**
       * Set current sequence index
       * @param {number} index - Sequence index
       */
      function setCurrentSequenceIndex(index) {
        currentSequenceIndex = index;
      }
      
      /**
       * Check if sequence is active
       * @return {boolean} Whether sequence is active
       */
      function isSequenceActive() {
        return currentSequenceIndex >= 0;
      }
      
      /**
       * Add action to history
       * @param {Object} action - Action data
       */
      function addActionToHistory(action) {
        // Limit history size
        if (actionHistory.length >= 50) {
          actionHistory.shift();
        }
        
        actionHistory.push(action);
      }
      
      /**
       * Pop action from history
       * @return {Object} Action data
       */
      function popActionFromHistory() {
        return actionHistory.pop();
      }
      
      /**
       * Get action history
       * @return {Array} Action history
       */
      function getActionHistory() {
        return actionHistory;
      }
      
      /**
       * Capture current state snapshot
       * @return {Object} State snapshot
       */
      function captureStateSnapshot() {
        const snapshot = {
          sequenceIndex: currentSequenceIndex,
          timestamp: Date.now()
        };
        
        // Additional state data can be added here
        
        return snapshot;
      }
      
      /**
       * Add overlay timing for YouTube video
       * @param {string} elementId - Element ID
       * @param {number} startTime - Start time in seconds
       * @param {number} endTime - End time in seconds
       * @param {string} animation - Animation type
       * @return {boolean} Success
       */
      function addOverlayTiming(elementId, startTime, endTime, animation = null) {
        const slide = getCurrentSlide();
        if (!slide || slide.slideType !== 'youtube') return false;
        
        if (!slide.overlayTimings) {
          slide.overlayTimings = [];
        }
        
        // Check if timing already exists
        const existingIndex = slide.overlayTimings.findIndex(t => t.elementId === elementId);
        if (existingIndex !== -1) {
          // Update existing timing
          slide.overlayTimings[existingIndex] = {
            elementId,
            startTime,
            endTime,
            animation
          };
        } else {
          // Add new timing
          slide.overlayTimings.push({
            elementId,
            startTime,
            endTime,
            animation
          });
        }
        
        projectDirty = true;
        return true;
      }
      
      /**
       * Remove overlay timing
       * @param {string} elementId - Element ID
       * @return {boolean} Success
       */
      function removeOverlayTiming(elementId) {
        const slide = getCurrentSlide();
        if (!slide || slide.slideType !== 'youtube' || !slide.overlayTimings) return false;
        
        slide.overlayTimings = slide.overlayTimings.filter(t => t.elementId !== elementId);
        projectDirty = true;
        return true;
      }
      
      /**
       * Get overlay timings
       * @return {Array} Overlay timings
       */
      function getOverlayTimings() {
        const slide = getCurrentSlide();
        if (!slide || slide.slideType !== 'youtube') return [];
        
        return slide.overlayTimings || [];
      }
      
      /**
       * Check if project has unsaved changes
       * @return {boolean} Whether project has unsaved changes
       */
      function isDirty() {
        if (!currentProject) return false;
        
        // If explicitly marked as dirty, return true
        if (projectDirty) return true;
        
        // Compare with last saved version if available
        if (lastSavedProjectData) {
          const currentData = getProjectJsonString();
          return currentData !== lastSavedProjectData;
        }
        
        // No saved version, so consider dirty if we have a project
        return true;
      }
      
        /**
         * Mark project as saved
         * @param {string} projectId - Project ID
         * @param {number} lastModified - Last modified timestamp
         */
        function markAsSaved(projectId, lastModified) {
        if (!currentProject) return;
        
        // Update project metadata
        currentProject.projectId = projectId;
        currentProject.modifiedAt = lastModified;
        
        // Store current state to compare against for dirty checking
        lastSavedProjectData = getProjectJsonString();
        projectDirty = false;
        
        // Update UI if in editor mode
        if (isEditorMode && typeof EditorUI !== 'undefined') {
            if (typeof EditorUI.updateSaveStatus === 'function') {
            EditorUI.updateSaveStatus(false, lastModified);
            }
            if (typeof EditorUI.updateProjectTitleDisplay === 'function') {
            EditorUI.updateProjectTitleDisplay();
            }
        }
        }
      
      // Public API
      return {
        init,
        createNewProject,
        createSlide,
        loadProjectData,
        getProjectJsonString,
        getCurrentProject,
        getProjectTitle,
        getProjectId,
        getCurrentSlide,
        getSlides,
        getCurrentSlideId,
        setCurrentSlideId,
        updateSlideProperties,
        getElementData,
        addElementData,
        updateElementData,
        removeElementData,
        addSlide,
        deleteSlide,
        getSlideSequence,
        setSlideSequence,
        getCurrentSequenceIndex,
        setCurrentSequenceIndex,
        isSequenceActive,
        addActionToHistory,
        popActionFromHistory,
        getActionHistory,
        captureStateSnapshot,
        addOverlayTiming,
        removeOverlayTiming,
        getOverlayTimings,
        isDirty,
        markAsSaved
      };
    })();
    </script>