<script>
  /**
   * Client for server-side API calls
   */
  const ServerClient = (() => {
    // Track pending requests to prevent duplicates
    const pendingRequests = new Map();
    
    /**
     * Run a server function asynchronously
     * @param {string} functionName - Server function name
     * @param {...*} args - Function arguments
     * @return {Promise} Promise resolving to function result
     */
    function runAsync(functionName, ...args) {
      return new Promise((resolve, reject) => {
        const requestId = `${functionName}:${JSON.stringify(args)}`;
        
        // Check if this exact request is already pending
        if (pendingRequests.has(requestId)) {
          console.log(`Request already pending: ${requestId}`);
          return pendingRequests.get(requestId);
        }
        
        // Create a new promise
        const promise = new Promise((innerResolve, innerReject) => {
          Utils.showLoadingIndicator(true, `Processing ${functionName}...`);
          
          google.script.run
            .withSuccessHandler(result => {
              Utils.showLoadingIndicator(false);
              // Remove from pending requests
              pendingRequests.delete(requestId);
              innerResolve(result);
            })
            .withFailureHandler(error => {
              Utils.showLoadingIndicator(false);
              console.error(`Error in ${functionName}:`, error);
              // Remove from pending requests
              pendingRequests.delete(requestId);
              innerReject(error);
            })
            [functionName](...args);
        });
        
        // Store the promise
        pendingRequests.set(requestId, promise);
        
        // Return the promise
        promise.then(resolve).catch(reject);
      });
    }
    
    /**
     * Save project data
     * @param {string} jsonString - Project data as JSON string
     * @param {string} projectId - Project ID (if updating)
     * @param {string} title - Project title
     * @return {Promise} Promise resolving to save result
     */
    function saveProject(jsonString, projectId, title) {
      return runAsync('saveProjectData', jsonString, projectId, title);
    }
    
    /**
     * Load project data
     * @param {string} projectId - Project ID
     * @return {Promise} Promise resolving to project JSON string
     */
    function loadProject(projectId) {
      if (!projectId) {
        return Promise.reject(new Error('Project ID is required'));
      }
      return runAsync('loadProjectData', projectId);
    }
    
    /**
     * List all projects
     * @return {Promise} Promise resolving to list of projects
     */
    function listProjects() {
      return runAsync('listProjects');
    }

    /**
     * Delete a project
     * @param {string} projectId - Project ID
     * @return {Promise} Promise resolving to success status
     */
    function deleteProject(projectId) {
      if (!projectId) {
        return Promise.reject(new Error('Project ID is required'));
      }
      return runAsync('deleteProject', projectId);
    }

    /**
     * Upload an image
     * @param {string} dataUrl - Image data URL
     * @param {string} filename - Image filename
     * @return {Promise} Promise resolving to upload result
     */
    function uploadImage(dataUrl, filename) {
      if (!dataUrl || !dataUrl.startsWith('data:')) {
        return Promise.reject(new Error('Invalid image data URL'));
      }
      
      if (!filename) {
        filename = `image_${Date.now()}.png`;
      }
      
      return runAsync('saveImageFile', dataUrl, filename)
        .then(result => {
          if (!result || !result.fileId) {
            throw new Error('Server returned invalid file ID');
          }
          
          console.log(`Image uploaded successfully with fileId: ${result.fileId}`);
          return result;
        });
    }
    
    /**
     * Load an image
     * @param {string} fileId - Image file ID
     * @return {Promise} Promise resolving to image data URL
     */
    function loadImage(fileId) {
      if (!fileId) {
        return Promise.reject(new Error('File ID is required'));
      }
      
      // Create a cache key for this request
      const cacheKey = `image:${fileId}`;
      
      // Check browser cache first (sessionStorage)
      if (window.sessionStorage) {
        const cachedData = sessionStorage.getItem(cacheKey);
        if (cachedData) {
          console.log(`Using cached image data for fileId: ${fileId}`);
          return Promise.resolve(cachedData);
        }
      }
      
      return runAsync('getImageDataUrl', fileId)
        .then(dataUrl => {
          if (!dataUrl || !dataUrl.startsWith('data:')) {
            throw new Error('Server returned invalid data URL');
          }
          
          // Cache the result in sessionStorage
          if (window.sessionStorage) {
            try {
              sessionStorage.setItem(cacheKey, dataUrl);
            } catch (error) {
              console.warn('Failed to cache image data:', error);
              // Ignore errors (storage might be full)
            }
          }
          
          return dataUrl;
        })
        .catch(error => {
          console.error(`Failed to load image with fileId: ${fileId}`, error);
          throw error;
        });
    }
    
    /**
     * Upload an audio file
     * @param {string} dataUrl - Audio data URL
     * @param {string} filename - Audio filename
     * @return {Promise} Promise resolving to upload result
     */
    function uploadAudio(dataUrl, filename) {
      if (!dataUrl || !dataUrl.startsWith('data:')) {
        return Promise.reject(new Error('Invalid audio data URL'));
      }
      
      if (!filename) {
        filename = `audio_${Date.now()}.mp3`;
      }
      
      return runAsync('saveAudioFile', dataUrl, filename)
        .then(result => {
          if (!result || !result.fileId) {
            throw new Error('Server returned invalid file ID');
          }
          
          return result;
        });
    }
    
    /**
     * Load an audio file
     * @param {string} fileId - Audio file ID
     * @return {Promise} Promise resolving to audio data URL
     */
    function loadAudio(fileId) {
      if (!fileId) {
        return Promise.reject(new Error('File ID is required'));
      }
      
      return runAsync('getAudioDataUrl', fileId)
        .then(dataUrl => {
          if (!dataUrl || !dataUrl.startsWith('data:')) {
            throw new Error('Server returned invalid data URL');
          }
          
          return dataUrl;
        });
    }
    
    /**
     * Send quiz results to user
     * @param {Object} results - Quiz results
     * @param {string} userEmail - User email
     * @return {Promise} Promise resolving to send result
     */
    function sendQuizToUser(results, userEmail) {
      if (!results) {
        return Promise.reject(new Error('Quiz results are required'));
      }
      
      if (!userEmail || !userEmail.includes('@')) {
        return Promise.reject(new Error('Valid email address is required'));
      }
      
      return runAsync('sendQuizResultsToUser', results, userEmail);
    }
    
    /**
     * Send quiz results to creator
     * @param {Object} results - Quiz results
     * @param {string} creatorEmail - Creator email
     * @return {Promise} Promise resolving to send result
     */
    function sendQuizToCreator(results, creatorEmail) {
      if (!results) {
        return Promise.reject(new Error('Quiz results are required'));
      }
      
      if (!creatorEmail || !creatorEmail.includes('@')) {
        return Promise.reject(new Error('Valid email address is required'));
      }
      
      return runAsync('sendQuizResultsToCreator', results, creatorEmail);
    }
    
    /**
     * Clear image cache for a specific fileId or all images
     * @param {string} fileId - Optional file ID to clear specific cache
     */
    function clearImageCache(fileId = null) {
      if (window.sessionStorage) {
        if (fileId) {
          // Clear specific image
          sessionStorage.removeItem(`image:${fileId}`);
        } else {
          // Clear all cached images
          const keysToRemove = [];
          for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key.startsWith('image:')) {
              keysToRemove.push(key);
            }
          }
          
          keysToRemove.forEach(key => sessionStorage.removeItem(key));
        }
      }
    }
    
    // Public API
    return {
      saveProject,
      loadProject,
      listProjects,
      deleteProject,
      uploadImage,
      loadImage,
      uploadAudio,
      loadAudio,
      sendQuizToUser,
      sendQuizToCreator,
      clearImageCache
    };
  })();
  </script>