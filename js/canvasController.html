const CanvasController = (() => {
  let canvas = null;
  let currentSlideBg = { type: 'color', value: '#FFFFFF' }; // Track background
  let isEditor = false;

  // --- Private Fabric Helpers ---

  // Extended properties for serialization (include custom appData)
  const FABRIC_PROPS_TO_INCLUDE = [
      'id', 'appData', 'selectable', 'evented' // Include custom id and appData
      // Add other props if needed, like objectCaching for performance tuning
  ];

  function _initCanvas(id, editorMode = true) {
    isEditor = editorMode;
    canvas = new fabric.Canvas(id, {
      preserveObjectStacking: true,
      backgroundColor: '#FFFFFF', // Default background
      // Optimization flags (experiment as needed)
      // renderOnAddRemove: false, // Batch renders manually if needed
      // objectCaching: false, // Can sometimes interfere with complex styles/groups
      selection: isEditor, // Disable selection in viewer mode
      controlsAboveOverlay: true,
    });

    if (isEditor) {
        // Editor-specific event listeners
        canvas.on({
            'selection:created': _handleSelectionChange,
            'selection:updated': _handleSelectionChange,
            'selection:cleared': _handleSelectionChange,
            'object:modified': _handleObjectModified, // After move, scale, rotate
            // Consider 'object:moving', 'object:scaling', 'object:rotating' for real-time updates if needed
        });
         // Handle delete key
         window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (canvas.getActiveObject() && isEditor) {
                    deleteSelectedObject();
                }
            }
         });
    } else {
        // Viewer-specific settings
        canvas.selection = false; // Ensure selection is off
        canvas.hoverCursor = 'pointer'; // Indicate clickable items
        canvas.defaultCursor = 'default';
    }

    window.addEventListener('resize', Utils.debounce(resizeCanvas, 250));
    resizeCanvas(); // Initial size calculation
    console.log(`Canvas initialized for ${isEditor ? 'Editor' : 'Viewer'}`);
  }

  function _handleSelectionChange() {
      if (!isEditor) return;
      const activeObject = canvas.getActiveObject();
      EditorUI.updatePropertiesPanel(activeObject); // Update sidebar
      EditorUI.updateToolbarState(!!activeObject); // Enable/disable delete button etc.
  }

   function _handleObjectModified(e) {
      if (!isEditor || !e.target) return;
      const obj = e.target;
      const elementData = StateManager.getElementData(obj.id);

      if (elementData) {
            const updates = {
                left: obj.left,
                top: obj.top,
                angle: obj.angle,
                // Use getScaledWidth/Height to account for scaling factors
                width: obj.getScaledWidth(),
                height: obj.getScaledHeight(),
                // Reset scale factors after applying them to width/height
                scaleX: 1,
                scaleY: 1,
            };
             // If it's a group (like text on shape), update the contained objects?
             // Fabric handles group resizing internally, just need to save the new group dimensions.

            // Update scale for Textbox specifically (affects text wrap)
            if (obj.type === 'textbox') {
               updates.width = obj.width * obj.scaleX; // Textbox width is managed differently
            }
             // Reset scale on the object itself
            obj.set({ scaleX: 1, scaleY: 1 });

            StateManager.updateElementData(obj.id, updates);
            // Re-render properties panel if needed as values changed
            EditorUI.updatePropertiesPanel(obj);
            canvas.renderAll();
      }
  }


  function _applyStyle(fabricObject, styleData) {
      if (!fabricObject || !styleData) return;

       const styleUpdates = {};
       if (styleData.color) styleUpdates.fill = styleData.color;
       if (styleData.opacity !== undefined) styleUpdates.opacity = styleData.opacity;

       // Outline (Stroke)
       if (styleData.outlineEnabled) {
           styleUpdates.stroke = styleData.outlineColor || '#000000';
           styleUpdates.strokeWidth = styleData.outlineWidth || 1;
           styleUpdates.strokeDashArray = styleData.outlineStyle === 'dashed' ? [5, 5] : (styleData.outlineStyle === 'dotted' ? [1, 3] : null);
       } else {
           styleUpdates.stroke = null; // Remove stroke if disabled
           styleUpdates.strokeWidth = 0;
       }

       // Shadow
       if (styleData.shadowEnabled) {
           fabricObject.shadow = new fabric.Shadow({
               color: styleData.shadowColor || 'rgba(0,0,0,0.5)',
               blur: styleData.shadowBlur || 5,
               offsetX: styleData.shadowOffsetX || 3,
               offsetY: styleData.shadowOffsetY || 3,
           });
       } else {
           fabricObject.shadow = null; // Remove shadow
       }

        fabricObject.set(styleUpdates);
        // Note: Animation is handled by InteractionHandler, not direct style application
  }

   function _applyTextProperties(fabricTextObject, textData) {
       if (!fabricTextObject || !textData) return;
       const textUpdates = {};
       if (textData.content !== undefined) textUpdates.text = textData.content;
       if (textData.fontSize) textUpdates.fontSize = textData.fontSize;
       if (textData.fontFamily) textUpdates.fontFamily = textData.fontFamily; // Add dropdown later
       if (textData.fontWeight) textUpdates.fontWeight = textData.fontWeight; // bold
       if (textData.fontStyle) textUpdates.fontStyle = textData.fontStyle; // italic
       if (textData.underline) textUpdates.underline = textData.underline;
       if (textData.textAlign) textUpdates.textAlign = textData.textAlign; // left, center, right
       if (textData.lineHeight) textUpdates.lineHeight = textData.lineHeight;
       if (textData.fill) textUpdates.fill = textData.fill; // Text color

       fabricTextObject.set(textUpdates);
   }


  // --- Public API ---
  return {
    initCanvas: _initCanvas,

    getCanvas: () => canvas, // Expose canvas instance carefully

    resizeCanvas() {
        if (!canvas || !canvas.wrapperEl) return;
        const container = canvas.wrapperEl.parentNode;
        const width = container.clientWidth;
        const height = container.clientHeight;

        canvas.setWidth(width);
        canvas.setHeight(height);

        // Optional: Adjust zoom to fit content if needed, especially in viewer
        // if (!isEditor) { /* ... logic to fit bounds ... */ }

        canvas.renderAll();
    },

    loadSlide(slideData) {
        if (!canvas || !slideData) {
            console.error("Canvas or slide data not available for loading.");
            return;
        }
        canvas.clear(); // Clear existing objects
        _resetViewport(); // Reset zoom/pan

        // Set background (Image or Color)
        if (slideData.imageFileId) {
            currentSlideBg = { type: 'image', value: slideData.imageFileId };
            Utils.showLoadingIndicator(true, 'Loading Background...');
            ServerClient.loadImage(slideData.imageFileId)
                .then(dataUrl => {
                    fabric.Image.fromURL(dataUrl, (img) => {
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            // Scale image to fit canvas dimensions? Or use original size?
                            // Let's try scaling to fit the initial canvas size.
                            scaleX: canvas.width / img.width,
                            scaleY: canvas.height / img.height,
                            originX: 'left',
                            originY: 'top'
                            // TODO: Store background scaling/position?
                        });
                    });
                })
                .catch(err => {
                    console.error("Failed to load background image:", err);
                    Utils.showError(`Failed to load background: ${err.message}`);
                    canvas.setBackgroundColor(slideData.backgroundColor || '#FFFFFF', canvas.renderAll.bind(canvas));
                })
                .finally(() => Utils.showLoadingIndicator(false));

        } else {
            currentSlideBg = { type: 'color', value: slideData.backgroundColor || '#FFFFFF' };
            canvas.setBackgroundColor(currentSlideBg.value, canvas.renderAll.bind(canvas));
            canvas.backgroundImage = null; // Ensure no old image persists
        }


        // Add elements from slide data
        if (slideData.elements && slideData.elements.length > 0) {
            // Use requestIdleCallback or setTimeout to avoid blocking UI thread if many objects
             setTimeout(() => {
                slideData.elements.forEach(elementData => this.addObject(elementData, false)); // Add without immediate render
                canvas.renderAll(); // Render all at once after adding
                console.log(`Loaded ${slideData.elements.length} elements for slide ${slideData.slideId}`);
             }, 10); // Small delay
        } else {
             canvas.renderAll(); // Render background even if no elements
        }

        // Set initial visibility based on sequence (if applicable)
        InteractionHandler.applyInitialSequenceState();
    },

    // Add a single object to the canvas based on element data
    // Can be called during slide load or when user adds new element
    addObject(elementData, render = true) {
      if (!canvas || !elementData) return null;

      let fabricObject;
      const commonOptions = {
        left: elementData.left || 50, // Default position
        top: elementData.top || 50,
        angle: elementData.angle || 0,
        originX: 'left', // Use consistent origins
        originY: 'top',
        // Fabric-specific props
        borderColor: 'blue',
        cornerColor: 'blue',
        cornerSize: 8,
        transparentCorners: false,
        // Custom data storage
        id: elementData.id || Utils.generateUUID(), // Ensure ID exists
        appData: elementData // Store the full state manager data here
      };

       // Apply initial styles (color, opacity, etc.) - BEFORE creating object if possible
       commonOptions.fill = elementData.style?.color || '#FF4136'; // Default Red
       commonOptions.opacity = elementData.style?.opacity ?? 1.0; // Use nullish coalescing


      // --- Object Creation by Type ---
      switch (elementData.type) {
        case 'rect':
          fabricObject = new fabric.Rect({
            ...commonOptions,
            width: elementData.width || 100,
            height: elementData.height || 50,
          });
          break;

        case 'ellipse':
          fabricObject = new fabric.Ellipse({
            ...commonOptions,
            rx: (elementData.width || 100) / 2, // Ellipse uses radius
            ry: (elementData.height || 50) / 2,
          });
          break;

        case 'textbox':
           // Textbox is special, style applies to text content mainly
           commonOptions.fill = elementData.text?.fill || '#333333'; // Text color default
           fabricObject = new fabric.Textbox(elementData.text?.content || 'New Text', {
                ...commonOptions,
                width: elementData.width || 150,
                fontSize: elementData.text?.fontSize || 16,
                // Other text props applied via _applyTextProperties later
                // Make background transparent by default unless specified
                backgroundColor: elementData.style?.backgroundColor || 'rgba(0,0,0,0)',
                padding: 5 // Add some padding
           });
           _applyTextProperties(fabricObject, elementData.text);
           break;

        // --- TODO: Text on Shape (Group) ---
        // case 'shapeWithText': // Example: a rect with text inside
        //   const shape = new fabric.Rect({ /* shape options */ });
        //   const text = new fabric.Textbox('Text', { /* text options relative to shape */ });
        //   fabricObject = new fabric.Group([shape, text], { ...commonOptions });
        //   // Need logic to handle group resizing, text wrapping, and saving/loading group structure
        //   break;

        default:
          console.warn("Unsupported element type:", elementData.type);
          return null;
      }

      // Apply common styles (outline, shadow) after object creation
      _applyStyle(fabricObject, elementData.style);

      // Apply initial visibility (often handled by sequence handler)
       if (elementData.initiallyHidden) {
           fabricObject.visible = false;
       }

       // Set selectability/eventing based on mode
       fabricObject.selectable = isEditor;
       fabricObject.evented = true; // Always allow events (clicks)

      // Add to canvas
      canvas.add(fabricObject);

       // Attach interaction listeners (Viewer and Editor might need different ones?)
       InteractionHandler.attachListenersToObject(fabricObject);

      if (render) {
        canvas.requestRenderAll(); // Request render instead of immediate
      }

      return fabricObject; // Return the created fabric object
    },

    updateObjectFromData(elementId) {
         const fabricObj = this.getObjectById(elementId);
         const elementData = StateManager.getElementData(elementId);
         if (fabricObj && elementData) {
             // Update position, size, angle
             fabricObj.set({
                left: elementData.left,
                top: elementData.top,
                angle: elementData.angle,
             });
             // Update dimensions carefully based on type
              if (fabricObj.type === 'rect' || fabricObj.type === 'textbox') {
                    fabricObj.set({ width: elementData.width, height: elementData.height });
              } else if (fabricObj.type === 'ellipse') {
                   fabricObj.set({ rx: elementData.width / 2, ry: elementData.height / 2 });
              }
              // Reset scale just in case
              fabricObj.set({ scaleX: 1, scaleY: 1 });


             // Apply styles and text properties
             _applyStyle(fabricObj, elementData.style);
             if (fabricObj.type === 'textbox') {
                _applyTextProperties(fabricObj, elementData.text);
             }
             // Update visibility
             fabricObj.visible = !elementData.initiallyHidden; // Base visibility

             // Update the stored appData reference
             fabricObj.appData = elementData;

             canvas.requestRenderAll();
         }
    },

    removeObjectById(elementId) {
      const obj = this.getObjectById(elementId);
      if (obj) {
        canvas.remove(obj);
        canvas.requestRenderAll();
        return true;
      }
      return false;
    },

    deleteSelectedObject() {
        if (!isEditor) return;
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
            // If it's a multi-selection (ActiveSelection)
            if (activeObject.type === 'activeSelection') {
                activeObject.forEachObject(obj => {
                    StateManager.removeElementData(obj.id); // Remove from state
                    canvas.remove(obj); // Remove from canvas
                });
            } else {
                // Single object selected
                 StateManager.removeElementData(activeObject.id);
                 canvas.remove(activeObject);
            }
            canvas.discardActiveObject(); // Deselect
            canvas.requestRenderAll();
             EditorUI.updateSequenceList(); // Update sequence list as element is gone
        }
    },


    getObjectById(id) {
      return canvas.getObjects().find(o => o.id === id);
    },

    setActiveObject(elementId) {
        if (!isEditor) return;
        const obj = this.getObjectById(elementId);
        if (obj) {
            canvas.setActiveObject(obj);
            canvas.renderAll();
        } else {
             canvas.discardActiveObject();
             canvas.renderAll();
        }
        // Update properties panel
        _handleSelectionChange();
    },

     getActiveObjectId() {
        if (!isEditor) return null;
        const activeObj = canvas.getActiveObject();
        // Handle single vs multi-selection if needed differently
        return activeObj?.id;
     },

    // --- Viewport Manipulation (Pan/Zoom) ---
    getViewportTransform() {
        return canvas.viewportTransform; // [scaleX, skewY, skewX, scaleY, translateX, translateY]
    },

    setViewportTransform(transformArray, render = true) {
        canvas.setViewportTransform(transformArray);
        if (render) canvas.requestRenderAll();
    },

    zoomToPoint(point, zoomFactor, render = true) {
        // point is { x: ..., y: ... } in canvas coords
        canvas.zoomToPoint(point, zoomFactor);
        if (render) canvas.requestRenderAll();
    },

    pan(deltaX, deltaY, render = true) {
        canvas.relativePan(new fabric.Point(deltaX, deltaY));
         if (render) canvas.requestRenderAll();
    },

    animateViewport(targetTransform, duration = 500, onComplete = null) {
        const startTransform = this.getViewportTransform();
        fabric.util.animate({
            startValue: startTransform,
            endValue: targetTransform,
            duration: duration,
            onChange: (value) => {
                this.setViewportTransform(value, true); // Render each step
            },
            onComplete: () => {
                 this.setViewportTransform(targetTransform, true); // Ensure final state
                 if (onComplete) onComplete();
            },
            // easing: fabric.util.ease.easeInOutQuad // Add easing
        });
    },

    _resetViewport() {
        this.setViewportTransform([1, 0, 0, 1, 0, 0]); // Default transform (scale 1, no translation)
    },

    // --- Background Image Handling ---
    async setBackgroundImage(imageFileId) {
        if (!canvas) return;
        Utils.showLoadingIndicator(true, 'Setting Background...');
        try {
            const dataUrl = await ServerClient.loadImage(imageFileId);
            fabric.Image.fromURL(dataUrl, (img) => {
                 // Get current slide dimensions (or canvas if slide dimensions not stored)
                 const slide = StateManager.getCurrentSlide();
                 const targetWidth = slide?.imageWidth || canvas.width;
                 const targetHeight = slide?.imageHeight || canvas.height;

                 canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                    // Scale to fit the intended dimensions
                    scaleX: targetWidth / img.width,
                    scaleY: targetHeight / img.height,
                    originX: 'left',
                    originY: 'top'
                 });
                 // Update state manager
                 StateManager.updateSlideProperties(StateManager.getCurrentSlideId(), {
                     imageFileId: imageFileId,
                     imageUrl: `drive://${imageFileId}`, // Optional: store reference
                     imageWidth: img.width, // Store original image dimensions
                     imageHeight: img.height,
                     backgroundColor: null // Clear color if image is set
                 });
                 currentSlideBg = { type: 'image', value: imageFileId };
                 EditorUI.updateSlideBackgroundDisplay(imageFileId, "Image Loaded"); // Update UI
            });
        } catch (error) {
            console.error("Error setting background image:", error);
            Utils.showError(`Failed to set background: ${error.message}`);
        } finally {
             Utils.showLoadingIndicator(false);
        }
    },

    clearBackgroundImage() {
         if (!canvas) return;
         canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
         canvas.setBackgroundColor('#FFFFFF', canvas.renderAll.bind(canvas)); // Reset to default color
         StateManager.updateSlideProperties(StateManager.getCurrentSlideId(), {
             imageFileId: null,
             imageUrl: null,
             backgroundColor: '#FFFFFF'
         });
         currentSlideBg = { type: 'color', value: '#FFFFFF' };
         EditorUI.updateSlideBackgroundDisplay(null);
    },

    // --- Animation ---
     animateObject(elementId, animationType, duration = 500, onComplete = null) {
         const obj = this.getObjectById(elementId);
         if (!obj) return;

         let targetProps = {};
         let startProps = {}; // Store initial state for potential reversal

         switch (animationType) {
            case 'fadeIn':
                startProps = { opacity: 0 };
                targetProps = { opacity: obj.appData.style?.opacity ?? 1 }; // Fade to original opacity
                obj.set('opacity', 0); // Start transparent
                obj.visible = true; // Make sure it's visible for animation
                break;
            case 'fadeOut':
                 startProps = { opacity: obj.opacity };
                 targetProps = { opacity: 0 };
                 obj.visible = true;
                break;
            case 'pulse': // Requires multiple steps or custom animation logic
                 // Simple scale pulse example
                 const originalScaleX = obj.scaleX || 1;
                 const originalScaleY = obj.scaleY || 1;
                 startProps = { scaleX: originalScaleX, scaleY: originalScaleY};
                 targetProps = { scaleX: originalScaleX * 1.2, scaleY: originalScaleY * 1.2 };
                 obj.visible = true;
                 // Need to chain animation back to original scale
                 fabric.util.animate({
                     target: obj, // Animate the object directly
                     startValue: startProps.scaleX, // Animate scaleX
                     endValue: targetProps.scaleX,
                     duration: duration / 2,
                     onChange: canvas.renderAll.bind(canvas),
                     onComplete: () => {
                         fabric.util.animate({
                             target: obj,
                             startValue: targetProps.scaleX,
                             endValue: startProps.scaleX,
                             duration: duration / 2,
                             onChange: canvas.renderAll.bind(canvas),
                             onComplete: () => {
                                 obj.set({scaleX: originalScaleX, scaleY: originalScaleY }); // Ensure final state
                                 if (onComplete) onComplete();
                             }
                         });
                     },
                     // easing: fabric.util.ease.easeInOutSine
                 });
                 // Note: This only animates scaleX for simplicity. Need to do scaleY too.
                 // Returning here as the animation is handled internally.
                 return;
            // Add more cases: slideIn, bounce, etc.
            default:
                console.warn("Unsupported animation type:", animationType);
                return;
         }

         // Apply start state if needed (like for fadeIn)
         obj.set(startProps);

         // Use Fabric animation
         obj.animate(targetProps, {
            duration: duration,
            onChange: canvas.renderAll.bind(canvas), // Render during animation
            onComplete: () => {
                if (animationType === 'fadeOut') {
                    obj.visible = false; // Hide after fading out
                }
                 // Ensure final state is set explicitly
                 obj.set(targetProps);
                 if (animationType === 'fadeIn') obj.set({ opacity: obj.appData.style?.opacity ?? 1 }); // Ensure final opacity is correct

                canvas.renderAll();
                if (onComplete) onComplete();
            },
            // easing: fabric.util.ease.easeInOutQuad
         });
     }

  };
})();