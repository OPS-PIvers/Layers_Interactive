const InteractionHandler = (() => {
    let isViewer = false;
    let viewerNavContainer;
    let prevButton, nextButton, stepIndicator;

    function init(mode) {
        isViewer = (mode === 'viewer');
        if (isViewer) {
            viewerNavContainer = document.getElementById('viewer-navigation');
            prevButton = document.getElementById('prev-step-button');
            nextButton = document.getElementById('next-step-button');
            stepIndicator = document.getElementById('step-indicator');
            Utils.listen(prevButton, 'click', executePreviousStep);
            Utils.listen(nextButton, 'click', executeNextStep);
        }
    }

    function attachListenersToObject(fabricObject) {
        if (!fabricObject) return;
        const data = fabricObject.appData; // Data from StateManager

        // Remove previous listeners to prevent duplicates if re-attaching
        fabricObject.off('mousedown');
        fabricObject.off('mouseover');
        fabricObject.off('mouseout');

        // Add listener based on trigger config
        if (data?.interactions?.triggers?.onClick) {
            fabricObject.on('mousedown', () => handleInteractionTrigger(fabricObject));
        }
        // Add hover effects or listeners if needed later
        // if (data?.interactions?.triggers?.onHover) { ... }

        // Set cursor style (only really matters in viewer)
        if (!isViewer) {
            fabricObject.hoverCursor = 'move'; // Default editor cursor
        } else {
            // Set pointer cursor only if there's an interaction defined
            const hasInteraction = Object.values(data?.interactions?.features || {}).some(f => f.enabled);
            fabricObject.hoverCursor = hasInteraction ? 'pointer' : 'default';
        }
    }

    function handleInteractionTrigger(fabricObject) {
        const elementData = fabricObject.appData;
        if (!elementData || !elementData.interactions) return;

        console.log(`Interaction triggered by: ${elementData.nickname || elementData.id}`);

        // --- Viewer Sequence Logic ---
        if (isViewer && StateManager.isSequenceActive()) {
            // If click happens during sequence, only proceed if it's the *current* sequence item
            const currentSequenceIndex = StateManager.getCurrentSequenceIndex();
            const sequence = StateManager.getSlideSequence();
            if (sequence[currentSequenceIndex] !== elementData.id) {
                console.log("Clicked element is not the current sequence item. Ignoring.");
                // Optional: provide visual feedback that it's not the right item?
                 // Simple visual cue: quick flash/shake
                flashElement(fabricObject, '#EA4335'); // Flash red
                return; // Don't proceed
            }
             // If it *is* the current item, execute its action and advance
             executeActionForElement(elementData, fabricObject, true); // true = advance sequence after action

        } else if (isViewer && !StateManager.isSequenceActive()) {
            // Sequence not active, just perform the action directly without advancing
             executeActionForElement(elementData, fabricObject, false); // false = do not advance sequence

        } else if (!isViewer) {
             // In Editor mode, clicking might select or trigger a preview?
             // For now, editor click is handled by canvas selection.
             console.log("Interaction triggered in Editor mode (no action performed).");
        }
    }


    function executeActionForElement(elementData, fabricObject, advanceSequence) {
         const features = elementData.interactions?.features || {};
         let actionCompleted = false; // Flag to track if any action was actually performed

        // Store state *before* performing action (for potential undo)
        const preActionState = captureStateSnapshot(elementData.id); // Capture state relevant to this element/viewport


        // --- Execute Enabled Features ---
        // Order might matter if multiple features are enabled (e.g., zoom then reveal)

         // 1. Pan & Zoom
         if (features.panAndZoom?.enabled) {
             actionCompleted = true;
             console.log("Executing Pan & Zoom");
             const target = features.panAndZoom;
             const targetVp = calculateTargetViewport(target.targetX, target.targetY, target.targetZoom);
             CanvasController.animateViewport(targetVp, 500, () => {
                 console.log("Pan & Zoom animation complete.");
                  if (advanceSequence) { advanceSequenceAfterAction(elementData.id, 'panAndZoom', preActionState); }
             });
             // Note: If other actions need to happen *after* zoom, the callback structure gets complex.
             // For now, assume other actions happen concurrently or immediately after *initiating* the zoom.
         }

        // 2. Reveal / Hide
        if (features.reveal?.enabled && features.reveal.targetIds?.length > 0) {
            actionCompleted = true;
            console.log("Executing Reveal/Hide for targets:", features.reveal.targetIds);
            features.reveal.targetIds.forEach(targetId => {
                const targetObj = CanvasController.getObjectById(targetId);
                if (targetObj) {
                     // Toggle visibility or use specific animation? Let's toggle for now.
                     targetObj.visible = !targetObj.visible;
                     // TODO: Add animation (fadeIn/fadeOut) based on reveal config
                }
            });
            CanvasController.getCanvas().requestRenderAll();
        }

         // 3. Spotlight (Needs implementation - overlay?)
         if (features.spotlight?.enabled) {
              actionCompleted = true;
              console.warn("Spotlight feature execution not implemented.");
              // Logic: Create a semi-transparent overlay covering the canvas,
              // then "cut out" a shape (circle/rect) around the fabricObject.
              // This is complex and might require adding/removing temporary canvas objects.
         }

         // 4. Quiz
         if (features.quiz?.enabled) {
              actionCompleted = true;
              console.log("Executing Quiz");
              // Open the quiz player modal.
              // The QuizPlayer module will handle its own lifecycle and
              // will call back to advance the sequence when the quiz is finished.
              QuizPlayer.openQuiz(fabricObject, () => {
                  // This callback is executed when the quiz is fully completed and closed.
                  console.log("Quiz finished callback.");
                  if (advanceSequence) { advanceSequenceAfterAction(elementData.id, 'quiz', preActionState); }
              });
              // IMPORTANT: Sequence advance happens *inside* the QuizPlayer callback now.
              // We should not call advanceSequenceAfterAction immediately here for quizzes.
              return; // Stop further execution flow here for quiz, let the callback handle it.
         }

         // If any non-async action was completed and sequence needs advancing
         if (actionCompleted && advanceSequence && !features.panAndZoom?.enabled && !features.quiz?.enabled) {
             advanceSequenceAfterAction(elementData.id, 'other', preActionState);
         } else if (!actionCompleted) {
              console.log("Triggered element has no enabled features.");
              // Still advance sequence if it was the correct item, even if it does nothing?
              // This seems correct - clicking the right item moves forward.
               if (advanceSequence) { advanceSequenceAfterAction(elementData.id, 'no_op', preActionState); }
         }
    }

    // --- Sequence Navigation (Viewer Only) ---

    function applyInitialSequenceState() {
         if (!isViewer) return;
         const slide = StateManager.getCurrentSlide();
         const settings = StateManager.getViewerSettings();
         const sequence = slide?.sequence || [];

         if (settings.enablePrevNext && sequence.length > 0) {
             viewerNavContainer.style.display = 'flex';
             StateManager.startSequence(); // Set index to 0
             // Make all sequence items initially visible? Or apply initial visibility?
             // Let's assume elements marked 'initiallyHidden' ARE hidden,
             // and the sequence reveals them or interacts with them.
             // Hide all elements *in the sequence* initially? Or respect initiallyHidden?
             // Let's respect 'initiallyHidden'. The sequence steps will make them visible if needed.

             // Highlight the first item? (Optional)
             // highlightSequenceItem(sequence[0]);

         } else {
             viewerNavContainer.style.display = 'none';
             StateManager.setCurrentSequenceIndex(-1); // Ensure sequence is inactive
         }
         updateNavUI();
    }

    function advanceSequenceAfterAction(elementId, actionType, preActionState) {
         if (!isViewer || !StateManager.isSequenceActive()) return;

         const currentSequenceIndex = StateManager.getCurrentSequenceIndex();
         const sequence = StateManager.getSlideSequence();

         // Record the action taken for potential undo
         // The action recorded is *triggering* the element at the current index
         const actionRecord = {
            index: currentSequenceIndex,
            elementId: elementId,
            actionType: actionType, // 'panAndZoom', 'reveal', 'quiz', 'other', 'no_op'
            preStateSnapshot: preActionState // State before *this* action occurred
         };
         StateManager.addActionToHistory(actionRecord);
         console.log("Action recorded:", actionRecord);


         // Move to the next step
         const nextIndex = currentSequenceIndex + 1;
         if (nextIndex < sequence.length) {
             StateManager.setCurrentSequenceIndex(nextIndex);
             console.log("Advanced sequence to index:", nextIndex);
             // Optional: Automatically trigger the next action? Or wait for user click?
             // Current design implies user clicks the next item.
             // Optional: Highlight next item
             // highlightSequenceItem(sequence[nextIndex]);
         } else {
             console.log("End of sequence reached.");
             StateManager.setCurrentSequenceIndex(nextIndex); // Move index past the end
             // Optional: Show completion message?
         }
         updateNavUI();
    }

    function executeNextStep() {
        if (!isViewer || !StateManager.isSequenceActive()) return;

        const currentSequenceIndex = StateManager.getCurrentSequenceIndex();
        const sequence = StateManager.getSlideSequence();

        if (currentSequenceIndex >= sequence.length -1 ) {
            console.log("Already at or past the last step.");
            return; // Cannot go further
        }

        const targetElementId = sequence[currentSequenceIndex + 1];
        const targetElementData = StateManager.getElementData(targetElementId);
        const targetFabricObject = CanvasController.getObjectById(targetElementId);

        if (targetElementData && targetFabricObject) {
             console.log("Executing next step (manual nav):", targetElementId);
             // Execute action for the *next* item and advance state
             executeActionForElement(targetElementData, targetFabricObject, true);
        } else {
             console.warn(`Element data or object not found for next sequence item: ${targetElementId}. Advancing anyway.`);
             // If element is missing, still advance state but record a 'missing_element' action?
              const preActionState = captureStateSnapshot(null); // No specific element state
              advanceSequenceAfterAction(targetElementId, 'missing_element', preActionState);
        }
    }

    function executePreviousStep() {
        if (!isViewer || !StateManager.isSequenceActive()) return;

        const history = StateManager.getActionHistory();
        if (history.length === 0) {
            console.log("No actions in history to undo");
            return; // Cannot go back further
        }

        const lastAction = StateManager.popActionFromHistory();
        console.log("Executing previous step (undoing action):", lastAction);

        try {
            // --- Revert State Based on lastAction.preStateSnapshot ---
            const snapshot = lastAction.preStateSnapshot || {};
            
            // 1. Revert viewport transform if available
            if (snapshot.viewportTransform && Array.isArray(snapshot.viewportTransform)) {
                CanvasController.animateViewport(snapshot.viewportTransform, 300);
            }
            
            // 2. Revert element visibility
            if (snapshot.elementVisibility) {
                Object.entries(snapshot.elementVisibility).forEach(([id, isVisible]) => {
                    const obj = CanvasController.getObjectById(id);
                    if (obj) {
                        obj.visible = isVisible;
                        
                        // Also restore opacity if available
                        if (snapshot.elementOpacity && snapshot.elementOpacity[id] !== undefined) {
                            obj.opacity = snapshot.elementOpacity[id];
                        }
                    }
                });
                CanvasController.getCanvas().requestRenderAll();
            }
            
            // 3. Reset any element-specific state
            if (lastAction.elementId) {
                const targetObj = CanvasController.getObjectById(lastAction.elementId);
                if (targetObj) {
                    // Apply any element-specific restorations
                    if (snapshot.elementItselfVisibility && 
                        snapshot.elementItselfVisibility[lastAction.elementId] !== undefined) {
                        targetObj.visible = snapshot.elementItselfVisibility[lastAction.elementId];
                        CanvasController.getCanvas().requestRenderAll();
                    }
                }
            }
        } catch (error) {
            console.error("Error reverting to previous state:", error);
            // Continue with sequence index change even if visual state restoration fails
        }

        // Move the sequence index back
        StateManager.setCurrentSequenceIndex(lastAction.index);

        // Update UI (buttons will be re-enabled/disabled)
        updateNavUI();
    }

    function updateNavUI() {
        if (!isViewer || !viewerNavContainer) return;
        
        // Check if the navigation is visible
        if (viewerNavContainer.style.display === 'none') return;
        
        const currentIndex = StateManager.getCurrentSequenceIndex();
        const sequence = StateManager.getSlideSequence();
        const historyLength = StateManager.getActionHistory().length;
        
        // Previous Button State - disabled if history is empty
        if (prevButton) {
            prevButton.disabled = historyLength === 0;
        }
        
        // Next Button State - disabled if at or past end of sequence
        if (nextButton) {
            // Fix: Handle case where currentIndex could be -1 (no sequence active)
            nextButton.disabled = currentIndex < 0 || currentIndex >= sequence.length - 1;
        }
        
        // Step Indicator Text
        if (stepIndicator) {
            const currentStepNum = historyLength;
            const totalSteps = sequence.length;
            stepIndicator.textContent = `Step ${currentStepNum} / ${totalSteps}`;
        }
    }

    // --- Helper Functions ---

    function flashElement(fabricObject, color = '#FBBC05', duration = 300) {
        if (!fabricObject) return;
        const originalFill = fabricObject.fill;
        const originalStroke = fabricObject.stroke;
        // Apply flash style
        fabricObject.set({
            fill: color, // Flash with specified color
            // Or flash stroke?
            // stroke: color,
            // strokeWidth: (fabricObject.strokeWidth || 0) + 2
        });
        CanvasController.getCanvas().requestRenderAll();
        // Revert after duration
        setTimeout(() => {
            fabricObject.set({
                fill: originalFill,
                // stroke: originalStroke,
                // strokeWidth: fabricObject.strokeWidth ? fabricObject.strokeWidth - 2 : 0
            });
             CanvasController.getCanvas().requestRenderAll();
        }, duration);
    }

    function calculateTargetViewport(targetX, targetY, targetZoom) {
        // This needs refinement. How are targetX/Y defined?
        // Are they center points in original image coords? Canvas coords?
        // Assuming they are canvas coordinates for the desired center point.
        const canvas = CanvasController.getCanvas();
        const width = canvas.width;
        const height = canvas.height;

        // Calculate the translation needed to center targetX/Y in the viewport at the new zoom level
        const newTranslateX = width / 2 - targetX * targetZoom;
        const newTranslateY = height / 2 - targetY * targetZoom;

        return [targetZoom, 0, 0, targetZoom, newTranslateX, newTranslateY];
    }

     // Function to capture relevant state before an action
    function captureStateSnapshot(triggerElementId) {
        const snapshot = {
            sequenceIndex: StateManager.getCurrentSequenceIndex(),
            timestamp: Date.now()
        };

        // 1. Capture current viewport transform
        snapshot.viewportTransform = [...CanvasController.getViewportTransform()]; // Create copy

        // 2. Capture element visibility states (all elements)
        snapshot.elementVisibility = {};
        const slide = StateManager.getCurrentSlide();
        
        if (slide && slide.elements) {
            slide.elements.forEach(element => {
                const fabricObj = CanvasController.getObjectById(element.id);
                if (fabricObj) {
                    snapshot.elementVisibility[element.id] = fabricObj.visible;
                }
            });
        }

        // 3. Capture opacity values for elements that might be animating
        snapshot.elementOpacity = {};
        if (slide && slide.elements) {
            slide.elements.forEach(element => {
                const fabricObj = CanvasController.getObjectById(element.id);
                if (fabricObj) {
                    snapshot.elementOpacity[element.id] = fabricObj.opacity;
                }
            });
        }

        // 4. Store trigger element id for reference
        snapshot.triggerElementId = triggerElementId;
        
        return snapshot;
    }

    // --- Public API ---
    return {
        init,
        attachListenersToObject,
        handleInteractionTrigger, // Might be called directly? (e.g. from next button)
        applyInitialSequenceState, // Called by main.js or stateManager on load
        updateNavUI, // Called by StateManager when index changes
        executeNextStep, // Called by nav button
        executePreviousStep // Called by nav button
    };

})();